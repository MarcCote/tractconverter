#line 1 "numpy\\core\\src\\_sortmodule.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- c -*- */

/*
 * The purpose of this module is to add faster sort functions
 * that are type-specific.  This is done by altering the
 * function table for the builtin descriptors.
 *
 * These sorting functions are copied almost directly from numarray
 * with a few modifications (complex comparisons compare the imaginary
 * part if the real parts are equal, for example), and the names
 * are changed.
 *
 * The original sorting code is due to Charles R. Harris who wrote
 * it for numarray.
 */

/*
 * Quick sort is usually the fastest, but the worst case scenario can
 * be slower than the merge and heap sorts.  The merge sort requires
 * extra memory and so for large arrays may not be useful.
 *
 * The merge sort is *stable*, meaning that equal components
 * are unmoved from their entry versions, so it can be used to
 * implement lexigraphic sorting on multiple keys.
 *
 * The heap sort is included for completeness.
 */


#include "Python.h"
#include "numpy/noprefix.h"
#include "numpy/npy_math.h"
#include "numpy/halffloat.h"

#include "npy_config.h"

#define NOT_USED NPY_UNUSED(unused)
#define PYA_QS_STACK 100
#define SMALL_QUICKSORT 15
#define SMALL_MERGESORT 20
#define SMALL_STRING 16

/*
 *****************************************************************************
 **                        SWAP MACROS                                      **
 *****************************************************************************
 */

#line 59
#define BOOL_SWAP(a,b) {npy_bool tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define BYTE_SWAP(a,b) {npy_byte tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define UBYTE_SWAP(a,b) {npy_ubyte tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define SHORT_SWAP(a,b) {npy_short tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define USHORT_SWAP(a,b) {npy_ushort tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define INT_SWAP(a,b) {npy_int tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define UINT_SWAP(a,b) {npy_uint tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define LONG_SWAP(a,b) {npy_long tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define ULONG_SWAP(a,b) {npy_ulong tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define LONGLONG_SWAP(a,b) {npy_longlong tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define ULONGLONG_SWAP(a,b) {npy_ulonglong tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define HALF_SWAP(a,b) {npy_half tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define FLOAT_SWAP(a,b) {npy_float tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define DOUBLE_SWAP(a,b) {npy_double tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define LONGDOUBLE_SWAP(a,b) {npy_longdouble tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define CFLOAT_SWAP(a,b) {npy_cfloat tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define CDOUBLE_SWAP(a,b) {npy_cdouble tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define CLONGDOUBLE_SWAP(a,b) {npy_clongdouble tmp = (b); (b)=(a); (a) = tmp;}


#line 59
#define INTP_SWAP(a,b) {npy_intp tmp = (b); (b)=(a); (a) = tmp;}



/*
 *****************************************************************************
 **                        COMPARISON FUNCTIONS                             **
 *****************************************************************************
 */

#line 76
NPY_INLINE static int
BOOL_LT(Bool a, Bool b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
BYTE_LT(byte a, byte b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
UBYTE_LT(ubyte a, ubyte b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
SHORT_LT(short a, short b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
USHORT_LT(ushort a, ushort b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
INT_LT(int a, int b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
UINT_LT(uint a, uint b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
LONG_LT(long a, long b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
ULONG_LT(ulong a, ulong b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
LONGLONG_LT(longlong a, longlong b)
{
    return a < b;
}

#line 76
NPY_INLINE static int
ULONGLONG_LT(ulonglong a, ulonglong b)
{
    return a < b;
}



#line 89
NPY_INLINE static int
FLOAT_LT(float a, float b)
{
    return a < b || (b != b && a == a);
}

#line 89
NPY_INLINE static int
DOUBLE_LT(double a, double b)
{
    return a < b || (b != b && a == a);
}

#line 89
NPY_INLINE static int
LONGDOUBLE_LT(longdouble a, longdouble b)
{
    return a < b || (b != b && a == a);
}


NPY_INLINE static int
HALF_LT(npy_half a, npy_half b)
{
    int ret;

    if (npy_half_isnan(b)) {
        ret = !npy_half_isnan(a);
    } else {
        ret = !npy_half_isnan(a) && npy_half_lt_nonan(a, b);
    }

    return ret;
}

/*
 * For inline functions SUN recommends not using a return in the then part
 * of an if statement. It's a SUN compiler thing, so assign the return value
 * to a variable instead.
 */

#line 121
NPY_INLINE static int
CFLOAT_LT(cfloat a, cfloat b)
{
    int ret;

    if (a.real < b.real) {
        ret = a.imag == a.imag || b.imag != b.imag;
    }
    else if (a.real > b.real) {
        ret = b.imag != b.imag && a.imag == a.imag;
    }
    else if (a.real == b.real || (a.real != a.real && b.real != b.real)) {
        ret =  a.imag < b.imag || (b.imag != b.imag && a.imag == a.imag);
    }
    else {
        ret = b.real != b.real;
    }

    return ret;
}

#line 121
NPY_INLINE static int
CDOUBLE_LT(cdouble a, cdouble b)
{
    int ret;

    if (a.real < b.real) {
        ret = a.imag == a.imag || b.imag != b.imag;
    }
    else if (a.real > b.real) {
        ret = b.imag != b.imag && a.imag == a.imag;
    }
    else if (a.real == b.real || (a.real != a.real && b.real != b.real)) {
        ret =  a.imag < b.imag || (b.imag != b.imag && a.imag == a.imag);
    }
    else {
        ret = b.real != b.real;
    }

    return ret;
}

#line 121
NPY_INLINE static int
CLONGDOUBLE_LT(clongdouble a, clongdouble b)
{
    int ret;

    if (a.real < b.real) {
        ret = a.imag == a.imag || b.imag != b.imag;
    }
    else if (a.real > b.real) {
        ret = b.imag != b.imag && a.imag == a.imag;
    }
    else if (a.real == b.real || (a.real != a.real && b.real != b.real)) {
        ret =  a.imag < b.imag || (b.imag != b.imag && a.imag == a.imag);
    }
    else {
        ret = b.real != b.real;
    }

    return ret;
}



/* The PyObject functions are stubs for later use */
NPY_INLINE static int
PyObject_LT(PyObject *pa, PyObject *pb)
{
    return 0;
}


NPY_INLINE static void
STRING_COPY(char *s1, char *s2, size_t len)
{
    memcpy(s1, s2, len);
}


NPY_INLINE static void
STRING_SWAP(char *s1, char *s2, size_t len)
{
    while(len--) {
        const char t = *s1;
        *s1++ = *s2;
        *s2++ = t;
    }
}


NPY_INLINE static int
STRING_LT(char *s1, char *s2, size_t len)
{
    const unsigned char *c1 = (unsigned char *)s1;
    const unsigned char *c2 = (unsigned char *)s2;
    size_t i;
    int ret = 0;

    for (i = 0; i < len; ++i) {
        if (c1[i] != c2[i]) {
            ret = c1[i] < c2[i];
            break;
        }
    }
    return ret;
}


NPY_INLINE static void
UNICODE_COPY(npy_ucs4 *s1, npy_ucs4 *s2, size_t len)
{
    while(len--) {
        *s1++ = *s2++;
    }
}


NPY_INLINE static void
UNICODE_SWAP(npy_ucs4 *s1, npy_ucs4 *s2, size_t len)
{
    while(len--) {
        const npy_ucs4 t = *s1;
        *s1++ = *s2;
        *s2++ = t;
    }
}


NPY_INLINE static int
UNICODE_LT(npy_ucs4 *s1, npy_ucs4 *s2, size_t len)
{
    size_t i;
    int ret = 0;

    for (i = 0; i < len; ++i) {
        if (s1[i] != s2[i]) {
            ret = s1[i] < s2[i];
            break;
        }
    }
    return ret;
}


/*
 *****************************************************************************
 **                            NUMERIC SORTS                                **
 *****************************************************************************
 */


#line 240


static int
BOOL_quicksort(Bool *start, npy_intp num, void *NOT_USED)
{
    Bool *pl = start;
    Bool *pr = start + num - 1;
    Bool vp;
    Bool *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (BOOL_LT(*pm, *pl)) BOOL_SWAP(*pm, *pl);
            if (BOOL_LT(*pr, *pm)) BOOL_SWAP(*pr, *pm);
            if (BOOL_LT(*pm, *pl)) BOOL_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            BOOL_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (BOOL_LT(*pi, vp));
                do --pj; while (BOOL_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                BOOL_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            BOOL_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && BOOL_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
BOOL_aquicksort(Bool *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    Bool vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (BOOL_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (BOOL_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (BOOL_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (BOOL_LT(v[*pi],vp));
                do --pj; while (BOOL_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && BOOL_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
BOOL_heapsort(Bool *start, npy_intp n, void *NOT_USED)
{
    Bool tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && BOOL_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (BOOL_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && BOOL_LT(a[j], a[j+1])) {
                j++;
            }
            if (BOOL_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
BOOL_aheapsort(Bool *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && BOOL_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (BOOL_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && BOOL_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (BOOL_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
BOOL_mergesort0(Bool *pl, Bool *pr, Bool *pw)
{
    Bool vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        BOOL_mergesort0(pl, pm, pw);
        BOOL_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (BOOL_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && BOOL_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
BOOL_mergesort(Bool *start, npy_intp num, void *NOT_USED)
{
    Bool *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (Bool *) PyDataMem_NEW((num/2)*sizeof(Bool));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    BOOL_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
BOOL_amergesort0(npy_intp *pl, npy_intp *pr, Bool *v, npy_intp *pw)
{
    Bool vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        BOOL_amergesort0(pl,pm-1,v,pw);
        BOOL_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (BOOL_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && BOOL_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
BOOL_amergesort(Bool *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    BOOL_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
BYTE_quicksort(byte *start, npy_intp num, void *NOT_USED)
{
    byte *pl = start;
    byte *pr = start + num - 1;
    byte vp;
    byte *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (BYTE_LT(*pm, *pl)) BYTE_SWAP(*pm, *pl);
            if (BYTE_LT(*pr, *pm)) BYTE_SWAP(*pr, *pm);
            if (BYTE_LT(*pm, *pl)) BYTE_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            BYTE_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (BYTE_LT(*pi, vp));
                do --pj; while (BYTE_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                BYTE_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            BYTE_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && BYTE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
BYTE_aquicksort(byte *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    byte vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (BYTE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (BYTE_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (BYTE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (BYTE_LT(v[*pi],vp));
                do --pj; while (BYTE_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && BYTE_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
BYTE_heapsort(byte *start, npy_intp n, void *NOT_USED)
{
    byte tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && BYTE_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (BYTE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && BYTE_LT(a[j], a[j+1])) {
                j++;
            }
            if (BYTE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
BYTE_aheapsort(byte *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && BYTE_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (BYTE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && BYTE_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (BYTE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
BYTE_mergesort0(byte *pl, byte *pr, byte *pw)
{
    byte vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        BYTE_mergesort0(pl, pm, pw);
        BYTE_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (BYTE_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && BYTE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
BYTE_mergesort(byte *start, npy_intp num, void *NOT_USED)
{
    byte *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (byte *) PyDataMem_NEW((num/2)*sizeof(byte));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    BYTE_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
BYTE_amergesort0(npy_intp *pl, npy_intp *pr, byte *v, npy_intp *pw)
{
    byte vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        BYTE_amergesort0(pl,pm-1,v,pw);
        BYTE_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (BYTE_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && BYTE_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
BYTE_amergesort(byte *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    BYTE_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
UBYTE_quicksort(ubyte *start, npy_intp num, void *NOT_USED)
{
    ubyte *pl = start;
    ubyte *pr = start + num - 1;
    ubyte vp;
    ubyte *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (UBYTE_LT(*pm, *pl)) UBYTE_SWAP(*pm, *pl);
            if (UBYTE_LT(*pr, *pm)) UBYTE_SWAP(*pr, *pm);
            if (UBYTE_LT(*pm, *pl)) UBYTE_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            UBYTE_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (UBYTE_LT(*pi, vp));
                do --pj; while (UBYTE_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                UBYTE_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            UBYTE_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && UBYTE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
UBYTE_aquicksort(ubyte *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    ubyte vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (UBYTE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (UBYTE_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (UBYTE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (UBYTE_LT(v[*pi],vp));
                do --pj; while (UBYTE_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && UBYTE_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
UBYTE_heapsort(ubyte *start, npy_intp n, void *NOT_USED)
{
    ubyte tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && UBYTE_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (UBYTE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && UBYTE_LT(a[j], a[j+1])) {
                j++;
            }
            if (UBYTE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
UBYTE_aheapsort(ubyte *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && UBYTE_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (UBYTE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && UBYTE_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (UBYTE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
UBYTE_mergesort0(ubyte *pl, ubyte *pr, ubyte *pw)
{
    ubyte vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        UBYTE_mergesort0(pl, pm, pw);
        UBYTE_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (UBYTE_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && UBYTE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
UBYTE_mergesort(ubyte *start, npy_intp num, void *NOT_USED)
{
    ubyte *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (ubyte *) PyDataMem_NEW((num/2)*sizeof(ubyte));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    UBYTE_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
UBYTE_amergesort0(npy_intp *pl, npy_intp *pr, ubyte *v, npy_intp *pw)
{
    ubyte vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        UBYTE_amergesort0(pl,pm-1,v,pw);
        UBYTE_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (UBYTE_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && UBYTE_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
UBYTE_amergesort(ubyte *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    UBYTE_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
SHORT_quicksort(short *start, npy_intp num, void *NOT_USED)
{
    short *pl = start;
    short *pr = start + num - 1;
    short vp;
    short *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (SHORT_LT(*pm, *pl)) SHORT_SWAP(*pm, *pl);
            if (SHORT_LT(*pr, *pm)) SHORT_SWAP(*pr, *pm);
            if (SHORT_LT(*pm, *pl)) SHORT_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            SHORT_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (SHORT_LT(*pi, vp));
                do --pj; while (SHORT_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                SHORT_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            SHORT_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && SHORT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
SHORT_aquicksort(short *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    short vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (SHORT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (SHORT_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (SHORT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (SHORT_LT(v[*pi],vp));
                do --pj; while (SHORT_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && SHORT_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
SHORT_heapsort(short *start, npy_intp n, void *NOT_USED)
{
    short tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && SHORT_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (SHORT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && SHORT_LT(a[j], a[j+1])) {
                j++;
            }
            if (SHORT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
SHORT_aheapsort(short *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && SHORT_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (SHORT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && SHORT_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (SHORT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
SHORT_mergesort0(short *pl, short *pr, short *pw)
{
    short vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        SHORT_mergesort0(pl, pm, pw);
        SHORT_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (SHORT_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && SHORT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
SHORT_mergesort(short *start, npy_intp num, void *NOT_USED)
{
    short *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (short *) PyDataMem_NEW((num/2)*sizeof(short));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    SHORT_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
SHORT_amergesort0(npy_intp *pl, npy_intp *pr, short *v, npy_intp *pw)
{
    short vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        SHORT_amergesort0(pl,pm-1,v,pw);
        SHORT_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (SHORT_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && SHORT_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
SHORT_amergesort(short *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    SHORT_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
USHORT_quicksort(ushort *start, npy_intp num, void *NOT_USED)
{
    ushort *pl = start;
    ushort *pr = start + num - 1;
    ushort vp;
    ushort *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (USHORT_LT(*pm, *pl)) USHORT_SWAP(*pm, *pl);
            if (USHORT_LT(*pr, *pm)) USHORT_SWAP(*pr, *pm);
            if (USHORT_LT(*pm, *pl)) USHORT_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            USHORT_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (USHORT_LT(*pi, vp));
                do --pj; while (USHORT_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                USHORT_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            USHORT_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && USHORT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
USHORT_aquicksort(ushort *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    ushort vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (USHORT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (USHORT_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (USHORT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (USHORT_LT(v[*pi],vp));
                do --pj; while (USHORT_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && USHORT_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
USHORT_heapsort(ushort *start, npy_intp n, void *NOT_USED)
{
    ushort tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && USHORT_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (USHORT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && USHORT_LT(a[j], a[j+1])) {
                j++;
            }
            if (USHORT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
USHORT_aheapsort(ushort *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && USHORT_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (USHORT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && USHORT_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (USHORT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
USHORT_mergesort0(ushort *pl, ushort *pr, ushort *pw)
{
    ushort vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        USHORT_mergesort0(pl, pm, pw);
        USHORT_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (USHORT_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && USHORT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
USHORT_mergesort(ushort *start, npy_intp num, void *NOT_USED)
{
    ushort *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (ushort *) PyDataMem_NEW((num/2)*sizeof(ushort));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    USHORT_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
USHORT_amergesort0(npy_intp *pl, npy_intp *pr, ushort *v, npy_intp *pw)
{
    ushort vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        USHORT_amergesort0(pl,pm-1,v,pw);
        USHORT_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (USHORT_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && USHORT_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
USHORT_amergesort(ushort *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    USHORT_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
INT_quicksort(int *start, npy_intp num, void *NOT_USED)
{
    int *pl = start;
    int *pr = start + num - 1;
    int vp;
    int *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (INT_LT(*pm, *pl)) INT_SWAP(*pm, *pl);
            if (INT_LT(*pr, *pm)) INT_SWAP(*pr, *pm);
            if (INT_LT(*pm, *pl)) INT_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            INT_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (INT_LT(*pi, vp));
                do --pj; while (INT_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                INT_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INT_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && INT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
INT_aquicksort(int *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    int vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (INT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (INT_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (INT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (INT_LT(v[*pi],vp));
                do --pj; while (INT_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && INT_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
INT_heapsort(int *start, npy_intp n, void *NOT_USED)
{
    int tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && INT_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (INT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && INT_LT(a[j], a[j+1])) {
                j++;
            }
            if (INT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
INT_aheapsort(int *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && INT_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (INT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && INT_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (INT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
INT_mergesort0(int *pl, int *pr, int *pw)
{
    int vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        INT_mergesort0(pl, pm, pw);
        INT_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (INT_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && INT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
INT_mergesort(int *start, npy_intp num, void *NOT_USED)
{
    int *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (int *) PyDataMem_NEW((num/2)*sizeof(int));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    INT_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
INT_amergesort0(npy_intp *pl, npy_intp *pr, int *v, npy_intp *pw)
{
    int vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        INT_amergesort0(pl,pm-1,v,pw);
        INT_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (INT_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && INT_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
INT_amergesort(int *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    INT_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
UINT_quicksort(uint *start, npy_intp num, void *NOT_USED)
{
    uint *pl = start;
    uint *pr = start + num - 1;
    uint vp;
    uint *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (UINT_LT(*pm, *pl)) UINT_SWAP(*pm, *pl);
            if (UINT_LT(*pr, *pm)) UINT_SWAP(*pr, *pm);
            if (UINT_LT(*pm, *pl)) UINT_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            UINT_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (UINT_LT(*pi, vp));
                do --pj; while (UINT_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                UINT_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            UINT_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && UINT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
UINT_aquicksort(uint *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    uint vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (UINT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (UINT_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (UINT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (UINT_LT(v[*pi],vp));
                do --pj; while (UINT_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && UINT_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
UINT_heapsort(uint *start, npy_intp n, void *NOT_USED)
{
    uint tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && UINT_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (UINT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && UINT_LT(a[j], a[j+1])) {
                j++;
            }
            if (UINT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
UINT_aheapsort(uint *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && UINT_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (UINT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && UINT_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (UINT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
UINT_mergesort0(uint *pl, uint *pr, uint *pw)
{
    uint vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        UINT_mergesort0(pl, pm, pw);
        UINT_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (UINT_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && UINT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
UINT_mergesort(uint *start, npy_intp num, void *NOT_USED)
{
    uint *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (uint *) PyDataMem_NEW((num/2)*sizeof(uint));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    UINT_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
UINT_amergesort0(npy_intp *pl, npy_intp *pr, uint *v, npy_intp *pw)
{
    uint vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        UINT_amergesort0(pl,pm-1,v,pw);
        UINT_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (UINT_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && UINT_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
UINT_amergesort(uint *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    UINT_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
LONG_quicksort(long *start, npy_intp num, void *NOT_USED)
{
    long *pl = start;
    long *pr = start + num - 1;
    long vp;
    long *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (LONG_LT(*pm, *pl)) LONG_SWAP(*pm, *pl);
            if (LONG_LT(*pr, *pm)) LONG_SWAP(*pr, *pm);
            if (LONG_LT(*pm, *pl)) LONG_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            LONG_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (LONG_LT(*pi, vp));
                do --pj; while (LONG_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                LONG_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            LONG_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && LONG_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
LONG_aquicksort(long *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    long vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (LONG_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (LONG_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (LONG_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (LONG_LT(v[*pi],vp));
                do --pj; while (LONG_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && LONG_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
LONG_heapsort(long *start, npy_intp n, void *NOT_USED)
{
    long tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && LONG_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (LONG_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && LONG_LT(a[j], a[j+1])) {
                j++;
            }
            if (LONG_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
LONG_aheapsort(long *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && LONG_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (LONG_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && LONG_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (LONG_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
LONG_mergesort0(long *pl, long *pr, long *pw)
{
    long vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        LONG_mergesort0(pl, pm, pw);
        LONG_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (LONG_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && LONG_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
LONG_mergesort(long *start, npy_intp num, void *NOT_USED)
{
    long *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (long *) PyDataMem_NEW((num/2)*sizeof(long));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    LONG_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
LONG_amergesort0(npy_intp *pl, npy_intp *pr, long *v, npy_intp *pw)
{
    long vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        LONG_amergesort0(pl,pm-1,v,pw);
        LONG_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (LONG_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && LONG_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
LONG_amergesort(long *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    LONG_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
ULONG_quicksort(ulong *start, npy_intp num, void *NOT_USED)
{
    ulong *pl = start;
    ulong *pr = start + num - 1;
    ulong vp;
    ulong *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (ULONG_LT(*pm, *pl)) ULONG_SWAP(*pm, *pl);
            if (ULONG_LT(*pr, *pm)) ULONG_SWAP(*pr, *pm);
            if (ULONG_LT(*pm, *pl)) ULONG_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            ULONG_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (ULONG_LT(*pi, vp));
                do --pj; while (ULONG_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                ULONG_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            ULONG_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && ULONG_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
ULONG_aquicksort(ulong *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    ulong vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (ULONG_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (ULONG_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (ULONG_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (ULONG_LT(v[*pi],vp));
                do --pj; while (ULONG_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && ULONG_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
ULONG_heapsort(ulong *start, npy_intp n, void *NOT_USED)
{
    ulong tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && ULONG_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (ULONG_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && ULONG_LT(a[j], a[j+1])) {
                j++;
            }
            if (ULONG_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
ULONG_aheapsort(ulong *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && ULONG_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (ULONG_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && ULONG_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (ULONG_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
ULONG_mergesort0(ulong *pl, ulong *pr, ulong *pw)
{
    ulong vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        ULONG_mergesort0(pl, pm, pw);
        ULONG_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (ULONG_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && ULONG_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
ULONG_mergesort(ulong *start, npy_intp num, void *NOT_USED)
{
    ulong *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (ulong *) PyDataMem_NEW((num/2)*sizeof(ulong));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    ULONG_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
ULONG_amergesort0(npy_intp *pl, npy_intp *pr, ulong *v, npy_intp *pw)
{
    ulong vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        ULONG_amergesort0(pl,pm-1,v,pw);
        ULONG_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (ULONG_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && ULONG_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
ULONG_amergesort(ulong *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    ULONG_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
LONGLONG_quicksort(longlong *start, npy_intp num, void *NOT_USED)
{
    longlong *pl = start;
    longlong *pr = start + num - 1;
    longlong vp;
    longlong *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (LONGLONG_LT(*pm, *pl)) LONGLONG_SWAP(*pm, *pl);
            if (LONGLONG_LT(*pr, *pm)) LONGLONG_SWAP(*pr, *pm);
            if (LONGLONG_LT(*pm, *pl)) LONGLONG_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            LONGLONG_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (LONGLONG_LT(*pi, vp));
                do --pj; while (LONGLONG_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                LONGLONG_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            LONGLONG_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && LONGLONG_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
LONGLONG_aquicksort(longlong *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    longlong vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (LONGLONG_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (LONGLONG_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (LONGLONG_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (LONGLONG_LT(v[*pi],vp));
                do --pj; while (LONGLONG_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && LONGLONG_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
LONGLONG_heapsort(longlong *start, npy_intp n, void *NOT_USED)
{
    longlong tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && LONGLONG_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (LONGLONG_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && LONGLONG_LT(a[j], a[j+1])) {
                j++;
            }
            if (LONGLONG_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
LONGLONG_aheapsort(longlong *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && LONGLONG_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (LONGLONG_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && LONGLONG_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (LONGLONG_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
LONGLONG_mergesort0(longlong *pl, longlong *pr, longlong *pw)
{
    longlong vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        LONGLONG_mergesort0(pl, pm, pw);
        LONGLONG_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (LONGLONG_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && LONGLONG_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
LONGLONG_mergesort(longlong *start, npy_intp num, void *NOT_USED)
{
    longlong *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (longlong *) PyDataMem_NEW((num/2)*sizeof(longlong));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    LONGLONG_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
LONGLONG_amergesort0(npy_intp *pl, npy_intp *pr, longlong *v, npy_intp *pw)
{
    longlong vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        LONGLONG_amergesort0(pl,pm-1,v,pw);
        LONGLONG_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (LONGLONG_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && LONGLONG_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
LONGLONG_amergesort(longlong *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    LONGLONG_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
ULONGLONG_quicksort(ulonglong *start, npy_intp num, void *NOT_USED)
{
    ulonglong *pl = start;
    ulonglong *pr = start + num - 1;
    ulonglong vp;
    ulonglong *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (ULONGLONG_LT(*pm, *pl)) ULONGLONG_SWAP(*pm, *pl);
            if (ULONGLONG_LT(*pr, *pm)) ULONGLONG_SWAP(*pr, *pm);
            if (ULONGLONG_LT(*pm, *pl)) ULONGLONG_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            ULONGLONG_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (ULONGLONG_LT(*pi, vp));
                do --pj; while (ULONGLONG_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                ULONGLONG_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            ULONGLONG_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && ULONGLONG_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
ULONGLONG_aquicksort(ulonglong *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    ulonglong vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (ULONGLONG_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (ULONGLONG_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (ULONGLONG_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (ULONGLONG_LT(v[*pi],vp));
                do --pj; while (ULONGLONG_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && ULONGLONG_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
ULONGLONG_heapsort(ulonglong *start, npy_intp n, void *NOT_USED)
{
    ulonglong tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && ULONGLONG_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (ULONGLONG_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && ULONGLONG_LT(a[j], a[j+1])) {
                j++;
            }
            if (ULONGLONG_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
ULONGLONG_aheapsort(ulonglong *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && ULONGLONG_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (ULONGLONG_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && ULONGLONG_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (ULONGLONG_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
ULONGLONG_mergesort0(ulonglong *pl, ulonglong *pr, ulonglong *pw)
{
    ulonglong vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        ULONGLONG_mergesort0(pl, pm, pw);
        ULONGLONG_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (ULONGLONG_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && ULONGLONG_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
ULONGLONG_mergesort(ulonglong *start, npy_intp num, void *NOT_USED)
{
    ulonglong *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (ulonglong *) PyDataMem_NEW((num/2)*sizeof(ulonglong));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    ULONGLONG_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
ULONGLONG_amergesort0(npy_intp *pl, npy_intp *pr, ulonglong *v, npy_intp *pw)
{
    ulonglong vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        ULONGLONG_amergesort0(pl,pm-1,v,pw);
        ULONGLONG_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (ULONGLONG_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && ULONGLONG_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
ULONGLONG_amergesort(ulonglong *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    ULONGLONG_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
HALF_quicksort(ushort *start, npy_intp num, void *NOT_USED)
{
    ushort *pl = start;
    ushort *pr = start + num - 1;
    ushort vp;
    ushort *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (HALF_LT(*pm, *pl)) HALF_SWAP(*pm, *pl);
            if (HALF_LT(*pr, *pm)) HALF_SWAP(*pr, *pm);
            if (HALF_LT(*pm, *pl)) HALF_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            HALF_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (HALF_LT(*pi, vp));
                do --pj; while (HALF_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                HALF_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            HALF_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && HALF_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
HALF_aquicksort(ushort *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    ushort vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (HALF_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (HALF_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (HALF_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (HALF_LT(v[*pi],vp));
                do --pj; while (HALF_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && HALF_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
HALF_heapsort(ushort *start, npy_intp n, void *NOT_USED)
{
    ushort tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && HALF_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (HALF_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && HALF_LT(a[j], a[j+1])) {
                j++;
            }
            if (HALF_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
HALF_aheapsort(ushort *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && HALF_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (HALF_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && HALF_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (HALF_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
HALF_mergesort0(ushort *pl, ushort *pr, ushort *pw)
{
    ushort vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        HALF_mergesort0(pl, pm, pw);
        HALF_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (HALF_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && HALF_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
HALF_mergesort(ushort *start, npy_intp num, void *NOT_USED)
{
    ushort *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (ushort *) PyDataMem_NEW((num/2)*sizeof(ushort));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    HALF_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
HALF_amergesort0(npy_intp *pl, npy_intp *pr, ushort *v, npy_intp *pw)
{
    ushort vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        HALF_amergesort0(pl,pm-1,v,pw);
        HALF_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (HALF_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && HALF_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
HALF_amergesort(ushort *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    HALF_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
FLOAT_quicksort(float *start, npy_intp num, void *NOT_USED)
{
    float *pl = start;
    float *pr = start + num - 1;
    float vp;
    float *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (FLOAT_LT(*pm, *pl)) FLOAT_SWAP(*pm, *pl);
            if (FLOAT_LT(*pr, *pm)) FLOAT_SWAP(*pr, *pm);
            if (FLOAT_LT(*pm, *pl)) FLOAT_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            FLOAT_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (FLOAT_LT(*pi, vp));
                do --pj; while (FLOAT_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                FLOAT_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            FLOAT_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && FLOAT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
FLOAT_aquicksort(float *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    float vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (FLOAT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (FLOAT_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (FLOAT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (FLOAT_LT(v[*pi],vp));
                do --pj; while (FLOAT_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && FLOAT_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
FLOAT_heapsort(float *start, npy_intp n, void *NOT_USED)
{
    float tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && FLOAT_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (FLOAT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && FLOAT_LT(a[j], a[j+1])) {
                j++;
            }
            if (FLOAT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
FLOAT_aheapsort(float *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && FLOAT_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (FLOAT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && FLOAT_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (FLOAT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
FLOAT_mergesort0(float *pl, float *pr, float *pw)
{
    float vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        FLOAT_mergesort0(pl, pm, pw);
        FLOAT_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (FLOAT_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && FLOAT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
FLOAT_mergesort(float *start, npy_intp num, void *NOT_USED)
{
    float *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (float *) PyDataMem_NEW((num/2)*sizeof(float));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    FLOAT_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
FLOAT_amergesort0(npy_intp *pl, npy_intp *pr, float *v, npy_intp *pw)
{
    float vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        FLOAT_amergesort0(pl,pm-1,v,pw);
        FLOAT_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (FLOAT_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && FLOAT_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
FLOAT_amergesort(float *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    FLOAT_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
DOUBLE_quicksort(double *start, npy_intp num, void *NOT_USED)
{
    double *pl = start;
    double *pr = start + num - 1;
    double vp;
    double *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (DOUBLE_LT(*pm, *pl)) DOUBLE_SWAP(*pm, *pl);
            if (DOUBLE_LT(*pr, *pm)) DOUBLE_SWAP(*pr, *pm);
            if (DOUBLE_LT(*pm, *pl)) DOUBLE_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            DOUBLE_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (DOUBLE_LT(*pi, vp));
                do --pj; while (DOUBLE_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                DOUBLE_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            DOUBLE_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && DOUBLE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
DOUBLE_aquicksort(double *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    double vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (DOUBLE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (DOUBLE_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (DOUBLE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (DOUBLE_LT(v[*pi],vp));
                do --pj; while (DOUBLE_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && DOUBLE_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
DOUBLE_heapsort(double *start, npy_intp n, void *NOT_USED)
{
    double tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && DOUBLE_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (DOUBLE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && DOUBLE_LT(a[j], a[j+1])) {
                j++;
            }
            if (DOUBLE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
DOUBLE_aheapsort(double *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && DOUBLE_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (DOUBLE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && DOUBLE_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (DOUBLE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
DOUBLE_mergesort0(double *pl, double *pr, double *pw)
{
    double vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        DOUBLE_mergesort0(pl, pm, pw);
        DOUBLE_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (DOUBLE_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && DOUBLE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
DOUBLE_mergesort(double *start, npy_intp num, void *NOT_USED)
{
    double *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (double *) PyDataMem_NEW((num/2)*sizeof(double));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    DOUBLE_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
DOUBLE_amergesort0(npy_intp *pl, npy_intp *pr, double *v, npy_intp *pw)
{
    double vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        DOUBLE_amergesort0(pl,pm-1,v,pw);
        DOUBLE_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (DOUBLE_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && DOUBLE_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
DOUBLE_amergesort(double *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    DOUBLE_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
LONGDOUBLE_quicksort(longdouble *start, npy_intp num, void *NOT_USED)
{
    longdouble *pl = start;
    longdouble *pr = start + num - 1;
    longdouble vp;
    longdouble *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (LONGDOUBLE_LT(*pm, *pl)) LONGDOUBLE_SWAP(*pm, *pl);
            if (LONGDOUBLE_LT(*pr, *pm)) LONGDOUBLE_SWAP(*pr, *pm);
            if (LONGDOUBLE_LT(*pm, *pl)) LONGDOUBLE_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            LONGDOUBLE_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (LONGDOUBLE_LT(*pi, vp));
                do --pj; while (LONGDOUBLE_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                LONGDOUBLE_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            LONGDOUBLE_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && LONGDOUBLE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
LONGDOUBLE_aquicksort(longdouble *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    longdouble vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (LONGDOUBLE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (LONGDOUBLE_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (LONGDOUBLE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (LONGDOUBLE_LT(v[*pi],vp));
                do --pj; while (LONGDOUBLE_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && LONGDOUBLE_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
LONGDOUBLE_heapsort(longdouble *start, npy_intp n, void *NOT_USED)
{
    longdouble tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && LONGDOUBLE_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (LONGDOUBLE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && LONGDOUBLE_LT(a[j], a[j+1])) {
                j++;
            }
            if (LONGDOUBLE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
LONGDOUBLE_aheapsort(longdouble *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && LONGDOUBLE_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (LONGDOUBLE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && LONGDOUBLE_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (LONGDOUBLE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
LONGDOUBLE_mergesort0(longdouble *pl, longdouble *pr, longdouble *pw)
{
    longdouble vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        LONGDOUBLE_mergesort0(pl, pm, pw);
        LONGDOUBLE_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (LONGDOUBLE_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && LONGDOUBLE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
LONGDOUBLE_mergesort(longdouble *start, npy_intp num, void *NOT_USED)
{
    longdouble *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (longdouble *) PyDataMem_NEW((num/2)*sizeof(longdouble));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    LONGDOUBLE_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
LONGDOUBLE_amergesort0(npy_intp *pl, npy_intp *pr, longdouble *v, npy_intp *pw)
{
    longdouble vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        LONGDOUBLE_amergesort0(pl,pm-1,v,pw);
        LONGDOUBLE_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (LONGDOUBLE_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && LONGDOUBLE_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
LONGDOUBLE_amergesort(longdouble *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    LONGDOUBLE_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
CFLOAT_quicksort(cfloat *start, npy_intp num, void *NOT_USED)
{
    cfloat *pl = start;
    cfloat *pr = start + num - 1;
    cfloat vp;
    cfloat *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (CFLOAT_LT(*pm, *pl)) CFLOAT_SWAP(*pm, *pl);
            if (CFLOAT_LT(*pr, *pm)) CFLOAT_SWAP(*pr, *pm);
            if (CFLOAT_LT(*pm, *pl)) CFLOAT_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            CFLOAT_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (CFLOAT_LT(*pi, vp));
                do --pj; while (CFLOAT_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                CFLOAT_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            CFLOAT_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && CFLOAT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
CFLOAT_aquicksort(cfloat *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    cfloat vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (CFLOAT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (CFLOAT_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (CFLOAT_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (CFLOAT_LT(v[*pi],vp));
                do --pj; while (CFLOAT_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && CFLOAT_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
CFLOAT_heapsort(cfloat *start, npy_intp n, void *NOT_USED)
{
    cfloat tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && CFLOAT_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (CFLOAT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && CFLOAT_LT(a[j], a[j+1])) {
                j++;
            }
            if (CFLOAT_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
CFLOAT_aheapsort(cfloat *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && CFLOAT_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (CFLOAT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && CFLOAT_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (CFLOAT_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
CFLOAT_mergesort0(cfloat *pl, cfloat *pr, cfloat *pw)
{
    cfloat vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        CFLOAT_mergesort0(pl, pm, pw);
        CFLOAT_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (CFLOAT_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && CFLOAT_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
CFLOAT_mergesort(cfloat *start, npy_intp num, void *NOT_USED)
{
    cfloat *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (cfloat *) PyDataMem_NEW((num/2)*sizeof(cfloat));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    CFLOAT_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
CFLOAT_amergesort0(npy_intp *pl, npy_intp *pr, cfloat *v, npy_intp *pw)
{
    cfloat vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        CFLOAT_amergesort0(pl,pm-1,v,pw);
        CFLOAT_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (CFLOAT_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && CFLOAT_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
CFLOAT_amergesort(cfloat *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    CFLOAT_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
CDOUBLE_quicksort(cdouble *start, npy_intp num, void *NOT_USED)
{
    cdouble *pl = start;
    cdouble *pr = start + num - 1;
    cdouble vp;
    cdouble *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (CDOUBLE_LT(*pm, *pl)) CDOUBLE_SWAP(*pm, *pl);
            if (CDOUBLE_LT(*pr, *pm)) CDOUBLE_SWAP(*pr, *pm);
            if (CDOUBLE_LT(*pm, *pl)) CDOUBLE_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            CDOUBLE_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (CDOUBLE_LT(*pi, vp));
                do --pj; while (CDOUBLE_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                CDOUBLE_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            CDOUBLE_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && CDOUBLE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
CDOUBLE_aquicksort(cdouble *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    cdouble vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (CDOUBLE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (CDOUBLE_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (CDOUBLE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (CDOUBLE_LT(v[*pi],vp));
                do --pj; while (CDOUBLE_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && CDOUBLE_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
CDOUBLE_heapsort(cdouble *start, npy_intp n, void *NOT_USED)
{
    cdouble tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && CDOUBLE_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (CDOUBLE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && CDOUBLE_LT(a[j], a[j+1])) {
                j++;
            }
            if (CDOUBLE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
CDOUBLE_aheapsort(cdouble *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && CDOUBLE_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (CDOUBLE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && CDOUBLE_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (CDOUBLE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
CDOUBLE_mergesort0(cdouble *pl, cdouble *pr, cdouble *pw)
{
    cdouble vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        CDOUBLE_mergesort0(pl, pm, pw);
        CDOUBLE_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (CDOUBLE_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && CDOUBLE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
CDOUBLE_mergesort(cdouble *start, npy_intp num, void *NOT_USED)
{
    cdouble *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (cdouble *) PyDataMem_NEW((num/2)*sizeof(cdouble));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    CDOUBLE_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
CDOUBLE_amergesort0(npy_intp *pl, npy_intp *pr, cdouble *v, npy_intp *pw)
{
    cdouble vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        CDOUBLE_amergesort0(pl,pm-1,v,pw);
        CDOUBLE_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (CDOUBLE_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && CDOUBLE_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
CDOUBLE_amergesort(cdouble *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    CDOUBLE_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}



#line 240


static int
CLONGDOUBLE_quicksort(clongdouble *start, npy_intp num, void *NOT_USED)
{
    clongdouble *pl = start;
    clongdouble *pr = start + num - 1;
    clongdouble vp;
    clongdouble *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (CLONGDOUBLE_LT(*pm, *pl)) CLONGDOUBLE_SWAP(*pm, *pl);
            if (CLONGDOUBLE_LT(*pr, *pm)) CLONGDOUBLE_SWAP(*pr, *pm);
            if (CLONGDOUBLE_LT(*pm, *pl)) CLONGDOUBLE_SWAP(*pm, *pl);
            vp = *pm;
            pi = pl;
            pj = pr - 1;
            CLONGDOUBLE_SWAP(*pm, *pj);
            for (;;) {
                do ++pi; while (CLONGDOUBLE_LT(*pi, vp));
                do --pj; while (CLONGDOUBLE_LT(vp, *pj));
                if (pi >= pj) {
                    break;
                }
                CLONGDOUBLE_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            CLONGDOUBLE_SWAP(*pi, *pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && CLONGDOUBLE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}

static int
CLONGDOUBLE_aquicksort(clongdouble *v, npy_intp* tosort, npy_intp num, void *NOT_USED)
{
    clongdouble vp;
    npy_intp *pl, *pr;
    npy_intp *stack[PYA_QS_STACK], **sptr=stack, *pm, *pi, *pj, *pk, vi;

    pl = tosort;
    pr = tosort + num - 1;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (CLONGDOUBLE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            if (CLONGDOUBLE_LT(v[*pr],v[*pm])) INTP_SWAP(*pr,*pm);
            if (CLONGDOUBLE_LT(v[*pm],v[*pl])) INTP_SWAP(*pm,*pl);
            vp = v[*pm];
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (CLONGDOUBLE_LT(v[*pi],vp));
                do --pj; while (CLONGDOUBLE_LT(vp,v[*pj]));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            pj = pi;
            pk = pi - 1;
            while (pj > pl && CLONGDOUBLE_LT(vp, v[*pk])) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static int
CLONGDOUBLE_heapsort(clongdouble *start, npy_intp n, void *NOT_USED)
{
    clongdouble tmp, *a;
    npy_intp i,j,l;

    /* The array needs to be offset by one for heapsort indexing */
    a = start - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && CLONGDOUBLE_LT(a[j], a[j+1])) {
                j += 1;
            }
            if (CLONGDOUBLE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && CLONGDOUBLE_LT(a[j], a[j+1])) {
                j++;
            }
            if (CLONGDOUBLE_LT(tmp, a[j])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static int
CLONGDOUBLE_aheapsort(clongdouble *v, npy_intp *tosort, npy_intp n, void *NOT_USED)
{
    npy_intp *a, i,j,l, tmp;
    /* The arrays need to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && CLONGDOUBLE_LT(v[a[j]], v[a[j+1]])) {
                j += 1;
            }
            if (CLONGDOUBLE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && CLONGDOUBLE_LT(v[a[j]], v[a[j+1]])) {
                j++;
            }
            if (CLONGDOUBLE_LT(v[tmp], v[a[j]])) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}

static void
CLONGDOUBLE_mergesort0(clongdouble *pl, clongdouble *pr, clongdouble *pw)
{
    clongdouble vp, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        CLONGDOUBLE_mergesort0(pl, pm, pw);
        CLONGDOUBLE_mergesort0(pm, pr, pw);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (CLONGDOUBLE_LT(*pm,*pj)) {
                *pk = *pm++;
            }
            else {
                *pk = *pj++;
            }
            pk++;
        }
        while(pj < pi) {
            *pk++ = *pj++;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vp = *pi;
            pj = pi;
            pk = pi -1;
            while (pj > pl && CLONGDOUBLE_LT(vp, *pk)) {
                *pj-- = *pk--;
            }
            *pj = vp;
        }
    }
}

static int
CLONGDOUBLE_mergesort(clongdouble *start, npy_intp num, void *NOT_USED)
{
    clongdouble *pl, *pr, *pw;

    pl = start;
    pr = pl + num;
    pw = (clongdouble *) PyDataMem_NEW((num/2)*sizeof(clongdouble));
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    CLONGDOUBLE_mergesort0(pl, pr, pw);

    PyDataMem_FREE(pw);
    return 0;
}

static void
CLONGDOUBLE_amergesort0(npy_intp *pl, npy_intp *pr, clongdouble *v, npy_intp *pw)
{
    clongdouble vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl + 1)>>1);
        CLONGDOUBLE_amergesort0(pl,pm-1,v,pw);
        CLONGDOUBLE_amergesort0(pm,pr,v,pw);
        for (pi = pw, pj = pl; pj < pm; ++pi, ++pj) {
            *pi = *pj;
        }
        for (pk = pw, pm = pl; pk < pi && pj <= pr; ++pm) {
            if (CLONGDOUBLE_LT(v[*pj],v[*pk])) {
                *pm = *pj;
                ++pj;
            }
            else {
                *pm = *pk;
                ++pk;
            }
        }
        for (; pk < pi; ++pm, ++pk) {
            *pm = *pk;
        }
    }
    else {
        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v[vi];
            for (pj = pi, pk = pi - 1; pj > pl && CLONGDOUBLE_LT(vp, v[*pk]); --pj, --pk) {
                *pj = *pk;
            }
            *pj = vi;
        }
    }
}

static int
CLONGDOUBLE_amergesort(clongdouble *v, npy_intp *tosort, npy_intp num, void *NOT_USED)
{
    npy_intp *pl, *pr, *pw;

    pl = tosort; pr = pl + num - 1;
    pw = PyDimMem_NEW((1+num/2));

    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }

    CLONGDOUBLE_amergesort0(pl, pr, v, pw);
    PyDimMem_FREE(pw);

    return 0;
}




/*
 *****************************************************************************
 **                             STRING SORTS                                **
 *****************************************************************************
 */


#line 603

static void
STRING_mergesort0(char *pl, char *pr, char *pw, char *vp, size_t len)
{
    char *pi, *pj, *pk, *pm;

    if ((size_t)(pr - pl) > SMALL_MERGESORT*len) {
        /* merge sort */
        pm = pl + (((pr - pl)/len) >> 1)*len;
        STRING_mergesort0(pl, pm, pw, vp, len);
        STRING_mergesort0(pm, pr, pw, vp, len);
        STRING_COPY(pw, pl, pm - pl);
        pi = pw + (pm - pl);
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (STRING_LT(pm, pj, len)) {
                STRING_COPY(pk, pm, len);
                pm += len;
            }
            else {
                STRING_COPY(pk, pj, len);
                pj += len;
            }
            pk += len;
        }
        STRING_COPY(pk, pj, pi - pj);
    }
    else {
        /* insertion sort */
        for (pi = pl + len; pi < pr; pi += len) {
            STRING_COPY(vp, pi, len);
            pj = pi;
            pk = pi - len;
            while (pj > pl && STRING_LT(vp, pk, len)) {
                STRING_COPY(pj, pk, len);
                pj -= len;
                pk -= len;
            }
            STRING_COPY(pj, vp, len);
        }
    }
}

static int
STRING_mergesort(char *start, npy_intp num, PyArrayObject *arr)
{
    const size_t elsize = arr->descr->elsize;
    const size_t len = elsize / sizeof(char);
    char *pl, *pr, *pw, *vp;
    int err = 0;

    pl = start;
    pr = pl + num*len;
    pw = (char *) PyDataMem_NEW((num/2)*elsize);
    if (!pw) {
        PyErr_NoMemory();
        err = -1;
        goto fail_0;
    }
    vp = (char *) PyDataMem_NEW(elsize);
    if (!vp) {
        PyErr_NoMemory();
        err = -1;
        goto fail_1;
    }
    STRING_mergesort0(pl, pr, pw, vp, len);

    PyDataMem_FREE(vp);
fail_1:
    PyDataMem_FREE(pw);
fail_0:
    return err;
}

static int
STRING_quicksort(char *start, npy_intp num, PyArrayObject *arr)
{
    const size_t len = arr->descr->elsize/sizeof(char);
    char *vp = malloc(arr->descr->elsize);
    char *pl = start;
    char *pr = start + (num - 1)*len;
    char *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((size_t)(pr - pl) > SMALL_QUICKSORT*len) {
            /* quicksort partition */
            pm = pl + (((pr - pl)/len) >> 1)*len;
            if (STRING_LT(pm, pl, len)) STRING_SWAP(pm, pl, len);
            if (STRING_LT(pr, pm, len)) STRING_SWAP(pr, pm, len);
            if (STRING_LT(pm, pl, len)) STRING_SWAP(pm, pl, len);
            STRING_COPY(vp, pm, len);
            pi = pl;
            pj = pr - len;
            STRING_SWAP(pm, pj, len);
            for (;;) {
                do pi += len; while (STRING_LT(pi, vp, len));
                do pj -= len; while (STRING_LT(vp, pj, len));
                if (pi >= pj) {
                    break;
                }
                STRING_SWAP(pi, pj, len);
            }
            pk = pr - len;
            STRING_SWAP(pi, pk, len);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + len;
                *sptr++ = pr;
                pr = pi - len;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - len;
                pl = pi + len;
            }
        }

        /* insertion sort */
        for (pi = pl + len; pi <= pr; pi += len) {
            STRING_COPY(vp, pi, len);
            pj = pi;
            pk = pi - len;
            while (pj > pl && STRING_LT(vp, pk, len)) {
                STRING_COPY(pj, pk, len);
                pj -= len;
                pk -= len;
            }
            STRING_COPY(pj, vp, len);
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    free(vp);
    return 0;
}


static int
STRING_heapsort(char *start, npy_intp n, PyArrayObject *arr)
{
    size_t len = arr->descr->elsize/sizeof(char);
    char *tmp = malloc(arr->descr->elsize);
    char *a = start - len;
    npy_intp i,j,l;

    for (l = n>>1; l > 0; --l) {
        STRING_COPY(tmp, a + l*len, len);
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && STRING_LT(a + j*len, a + (j+1)*len, len))
                j += 1;
            if (STRING_LT(tmp, a + j*len, len)) {
                STRING_COPY(a + i*len, a + j*len, len);
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        STRING_COPY(a + i*len, tmp, len);
    }

    for (; n > 1;) {
        STRING_COPY(tmp, a + n*len, len);
        STRING_COPY(a + n*len, a + len, len);
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && STRING_LT(a + j*len, a + (j+1)*len, len))
                j++;
            if (STRING_LT(tmp, a + j*len, len)) {
                STRING_COPY(a + i*len, a + j*len, len);
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        STRING_COPY(a + i*len, tmp, len);
    }

    free(tmp);
    return 0;
}


static int
STRING_aheapsort(char *v, npy_intp *tosort, npy_intp n, PyArrayObject *arr)
{
    size_t len = arr->descr->elsize/sizeof(char);
    npy_intp *a, i,j,l, tmp;

    /* The array needs to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && STRING_LT(v + a[j]*len, v + a[j+1]*len, len))
                j += 1;
            if (STRING_LT(v + tmp*len, v + a[j]*len, len)) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && STRING_LT(v + a[j]*len, v + a[j+1]*len, len))
                j++;
            if (STRING_LT(v + tmp*len, v + a[j]*len, len)) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}


static int
STRING_aquicksort(char *v, npy_intp* tosort, npy_intp num, PyArrayObject *arr)
{
    size_t len = arr->descr->elsize/sizeof(char);
    char *vp;
    npy_intp *pl = tosort;
    npy_intp *pr = tosort + num - 1;
    npy_intp *stack[PYA_QS_STACK];
    npy_intp **sptr=stack;
    npy_intp *pm, *pi, *pj, *pk, vi;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (STRING_LT(v + (*pm)*len, v + (*pl)*len, len)) INTP_SWAP(*pm, *pl);
            if (STRING_LT(v + (*pr)*len, v + (*pm)*len, len)) INTP_SWAP(*pr, *pm);
            if (STRING_LT(v + (*pm)*len, v + (*pl)*len, len)) INTP_SWAP(*pm, *pl);
            vp = v + (*pm)*len;
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (STRING_LT(v + (*pi)*len, vp, len));
                do --pj; while (STRING_LT(vp, v + (*pj)*len, len));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v + vi*len;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && STRING_LT(vp, v + (*pk)*len, len)) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static void
STRING_amergesort0(npy_intp *pl, npy_intp *pr, char *v, npy_intp *pw, int len)
{
    char *vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        STRING_amergesort0(pl,pm,v,pw,len);
        STRING_amergesort0(pm,pr,v,pw,len);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (STRING_LT(v + (*pm)*len, v + (*pj)*len, len)) {
                *pk = *pm++;
            } else {
                *pk = *pj++;
            }
            pk++;
        }
        while (pj < pi) {
            *pk++ = *pj++;
        }
    } else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vi = *pi;
            vp = v + vi*len;
            pj = pi;
            pk = pi -1;
            while (pj > pl && STRING_LT(vp, v + (*pk)*len, len)) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
    }
}


static int
STRING_amergesort(char *v, npy_intp *tosort, npy_intp num, PyArrayObject *arr)
{
    const size_t elsize = arr->descr->elsize;
    const size_t len = elsize / sizeof(char);
    npy_intp *pl, *pr, *pw;

    pl = tosort;
    pr = pl + num;
    pw = PyDimMem_NEW(num/2);
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    STRING_amergesort0(pl, pr, v, pw, len);

    PyDimMem_FREE(pw);
    return 0;
}

#line 603

static void
UNICODE_mergesort0(PyArray_UCS4 *pl, PyArray_UCS4 *pr, PyArray_UCS4 *pw, PyArray_UCS4 *vp, size_t len)
{
    PyArray_UCS4 *pi, *pj, *pk, *pm;

    if ((size_t)(pr - pl) > SMALL_MERGESORT*len) {
        /* merge sort */
        pm = pl + (((pr - pl)/len) >> 1)*len;
        UNICODE_mergesort0(pl, pm, pw, vp, len);
        UNICODE_mergesort0(pm, pr, pw, vp, len);
        UNICODE_COPY(pw, pl, pm - pl);
        pi = pw + (pm - pl);
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (UNICODE_LT(pm, pj, len)) {
                UNICODE_COPY(pk, pm, len);
                pm += len;
            }
            else {
                UNICODE_COPY(pk, pj, len);
                pj += len;
            }
            pk += len;
        }
        UNICODE_COPY(pk, pj, pi - pj);
    }
    else {
        /* insertion sort */
        for (pi = pl + len; pi < pr; pi += len) {
            UNICODE_COPY(vp, pi, len);
            pj = pi;
            pk = pi - len;
            while (pj > pl && UNICODE_LT(vp, pk, len)) {
                UNICODE_COPY(pj, pk, len);
                pj -= len;
                pk -= len;
            }
            UNICODE_COPY(pj, vp, len);
        }
    }
}

static int
UNICODE_mergesort(PyArray_UCS4 *start, npy_intp num, PyArrayObject *arr)
{
    const size_t elsize = arr->descr->elsize;
    const size_t len = elsize / sizeof(PyArray_UCS4);
    PyArray_UCS4 *pl, *pr, *pw, *vp;
    int err = 0;

    pl = start;
    pr = pl + num*len;
    pw = (PyArray_UCS4 *) PyDataMem_NEW((num/2)*elsize);
    if (!pw) {
        PyErr_NoMemory();
        err = -1;
        goto fail_0;
    }
    vp = (PyArray_UCS4 *) PyDataMem_NEW(elsize);
    if (!vp) {
        PyErr_NoMemory();
        err = -1;
        goto fail_1;
    }
    UNICODE_mergesort0(pl, pr, pw, vp, len);

    PyDataMem_FREE(vp);
fail_1:
    PyDataMem_FREE(pw);
fail_0:
    return err;
}

static int
UNICODE_quicksort(PyArray_UCS4 *start, npy_intp num, PyArrayObject *arr)
{
    const size_t len = arr->descr->elsize/sizeof(PyArray_UCS4);
    PyArray_UCS4 *vp = malloc(arr->descr->elsize);
    PyArray_UCS4 *pl = start;
    PyArray_UCS4 *pr = start + (num - 1)*len;
    PyArray_UCS4 *stack[PYA_QS_STACK], **sptr = stack, *pm, *pi, *pj, *pk;

    for (;;) {
        while ((size_t)(pr - pl) > SMALL_QUICKSORT*len) {
            /* quicksort partition */
            pm = pl + (((pr - pl)/len) >> 1)*len;
            if (UNICODE_LT(pm, pl, len)) UNICODE_SWAP(pm, pl, len);
            if (UNICODE_LT(pr, pm, len)) UNICODE_SWAP(pr, pm, len);
            if (UNICODE_LT(pm, pl, len)) UNICODE_SWAP(pm, pl, len);
            UNICODE_COPY(vp, pm, len);
            pi = pl;
            pj = pr - len;
            UNICODE_SWAP(pm, pj, len);
            for (;;) {
                do pi += len; while (UNICODE_LT(pi, vp, len));
                do pj -= len; while (UNICODE_LT(vp, pj, len));
                if (pi >= pj) {
                    break;
                }
                UNICODE_SWAP(pi, pj, len);
            }
            pk = pr - len;
            UNICODE_SWAP(pi, pk, len);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + len;
                *sptr++ = pr;
                pr = pi - len;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - len;
                pl = pi + len;
            }
        }

        /* insertion sort */
        for (pi = pl + len; pi <= pr; pi += len) {
            UNICODE_COPY(vp, pi, len);
            pj = pi;
            pk = pi - len;
            while (pj > pl && UNICODE_LT(vp, pk, len)) {
                UNICODE_COPY(pj, pk, len);
                pj -= len;
                pk -= len;
            }
            UNICODE_COPY(pj, vp, len);
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    free(vp);
    return 0;
}


static int
UNICODE_heapsort(PyArray_UCS4 *start, npy_intp n, PyArrayObject *arr)
{
    size_t len = arr->descr->elsize/sizeof(PyArray_UCS4);
    PyArray_UCS4 *tmp = malloc(arr->descr->elsize);
    PyArray_UCS4 *a = start - len;
    npy_intp i,j,l;

    for (l = n>>1; l > 0; --l) {
        UNICODE_COPY(tmp, a + l*len, len);
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && UNICODE_LT(a + j*len, a + (j+1)*len, len))
                j += 1;
            if (UNICODE_LT(tmp, a + j*len, len)) {
                UNICODE_COPY(a + i*len, a + j*len, len);
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        UNICODE_COPY(a + i*len, tmp, len);
    }

    for (; n > 1;) {
        UNICODE_COPY(tmp, a + n*len, len);
        UNICODE_COPY(a + n*len, a + len, len);
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && UNICODE_LT(a + j*len, a + (j+1)*len, len))
                j++;
            if (UNICODE_LT(tmp, a + j*len, len)) {
                UNICODE_COPY(a + i*len, a + j*len, len);
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        UNICODE_COPY(a + i*len, tmp, len);
    }

    free(tmp);
    return 0;
}


static int
UNICODE_aheapsort(PyArray_UCS4 *v, npy_intp *tosort, npy_intp n, PyArrayObject *arr)
{
    size_t len = arr->descr->elsize/sizeof(PyArray_UCS4);
    npy_intp *a, i,j,l, tmp;

    /* The array needs to be offset by one for heapsort indexing */
    a = tosort - 1;

    for (l = n>>1; l > 0; --l) {
        tmp = a[l];
        for (i = l, j = l<<1; j <= n;) {
            if (j < n && UNICODE_LT(v + a[j]*len, v + a[j+1]*len, len))
                j += 1;
            if (UNICODE_LT(v + tmp*len, v + a[j]*len, len)) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    for (; n > 1;) {
        tmp = a[n];
        a[n] = a[1];
        n -= 1;
        for (i = 1, j = 2; j <= n;) {
            if (j < n && UNICODE_LT(v + a[j]*len, v + a[j+1]*len, len))
                j++;
            if (UNICODE_LT(v + tmp*len, v + a[j]*len, len)) {
                a[i] = a[j];
                i = j;
                j += j;
            }
            else {
                break;
            }
        }
        a[i] = tmp;
    }

    return 0;
}


static int
UNICODE_aquicksort(PyArray_UCS4 *v, npy_intp* tosort, npy_intp num, PyArrayObject *arr)
{
    size_t len = arr->descr->elsize/sizeof(PyArray_UCS4);
    PyArray_UCS4 *vp;
    npy_intp *pl = tosort;
    npy_intp *pr = tosort + num - 1;
    npy_intp *stack[PYA_QS_STACK];
    npy_intp **sptr=stack;
    npy_intp *pm, *pi, *pj, *pk, vi;

    for (;;) {
        while ((pr - pl) > SMALL_QUICKSORT) {
            /* quicksort partition */
            pm = pl + ((pr - pl) >> 1);
            if (UNICODE_LT(v + (*pm)*len, v + (*pl)*len, len)) INTP_SWAP(*pm, *pl);
            if (UNICODE_LT(v + (*pr)*len, v + (*pm)*len, len)) INTP_SWAP(*pr, *pm);
            if (UNICODE_LT(v + (*pm)*len, v + (*pl)*len, len)) INTP_SWAP(*pm, *pl);
            vp = v + (*pm)*len;
            pi = pl;
            pj = pr - 1;
            INTP_SWAP(*pm,*pj);
            for (;;) {
                do ++pi; while (UNICODE_LT(v + (*pi)*len, vp, len));
                do --pj; while (UNICODE_LT(vp, v + (*pj)*len, len));
                if (pi >= pj) {
                    break;
                }
                INTP_SWAP(*pi,*pj);
            }
            pk = pr - 1;
            INTP_SWAP(*pi,*pk);
            /* push largest partition on stack */
            if (pi - pl < pr - pi) {
                *sptr++ = pi + 1;
                *sptr++ = pr;
                pr = pi - 1;
            }
            else {
                *sptr++ = pl;
                *sptr++ = pi - 1;
                pl = pi + 1;
            }
        }

        /* insertion sort */
        for (pi = pl + 1; pi <= pr; ++pi) {
            vi = *pi;
            vp = v + vi*len;
            pj = pi;
            pk = pi - 1;
            while (pj > pl && UNICODE_LT(vp, v + (*pk)*len, len)) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
        if (sptr == stack) {
            break;
        }
        pr = *(--sptr);
        pl = *(--sptr);
    }

    return 0;
}


static void
UNICODE_amergesort0(npy_intp *pl, npy_intp *pr, PyArray_UCS4 *v, npy_intp *pw, int len)
{
    PyArray_UCS4 *vp;
    npy_intp vi, *pi, *pj, *pk, *pm;

    if (pr - pl > SMALL_MERGESORT) {
        /* merge sort */
        pm = pl + ((pr - pl) >> 1);
        UNICODE_amergesort0(pl,pm,v,pw,len);
        UNICODE_amergesort0(pm,pr,v,pw,len);
        for (pi = pw, pj = pl; pj < pm;) {
            *pi++ = *pj++;
        }
        pj = pw;
        pk = pl;
        while (pj < pi && pm < pr) {
            if (UNICODE_LT(v + (*pm)*len, v + (*pj)*len, len)) {
                *pk = *pm++;
            } else {
                *pk = *pj++;
            }
            pk++;
        }
        while (pj < pi) {
            *pk++ = *pj++;
        }
    } else {
        /* insertion sort */
        for (pi = pl + 1; pi < pr; ++pi) {
            vi = *pi;
            vp = v + vi*len;
            pj = pi;
            pk = pi -1;
            while (pj > pl && UNICODE_LT(vp, v + (*pk)*len, len)) {
                *pj-- = *pk--;
            }
            *pj = vi;
        }
    }
}


static int
UNICODE_amergesort(PyArray_UCS4 *v, npy_intp *tosort, npy_intp num, PyArrayObject *arr)
{
    const size_t elsize = arr->descr->elsize;
    const size_t len = elsize / sizeof(PyArray_UCS4);
    npy_intp *pl, *pr, *pw;

    pl = tosort;
    pr = pl + num;
    pw = PyDimMem_NEW(num/2);
    if (!pw) {
        PyErr_NoMemory();
        return -1;
    }
    UNICODE_amergesort0(pl, pr, v, pw, len);

    PyDimMem_FREE(pw);
    return 0;
}


static void
add_sortfuncs(void)
{
    PyArray_Descr *descr;

    #line 985
    descr = PyArray_DescrFromType(PyArray_BOOL);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)BOOL_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)BOOL_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)BOOL_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)BOOL_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)BOOL_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)BOOL_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_BYTE);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)BYTE_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)BYTE_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)BYTE_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)BYTE_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)BYTE_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)BYTE_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_UBYTE);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)UBYTE_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)UBYTE_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)UBYTE_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)UBYTE_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)UBYTE_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)UBYTE_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_SHORT);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)SHORT_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)SHORT_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)SHORT_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)SHORT_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)SHORT_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)SHORT_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_USHORT);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)USHORT_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)USHORT_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)USHORT_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)USHORT_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)USHORT_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)USHORT_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_INT);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)INT_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)INT_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)INT_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)INT_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)INT_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)INT_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_UINT);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)UINT_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)UINT_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)UINT_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)UINT_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)UINT_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)UINT_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_LONG);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)LONG_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)LONG_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)LONG_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)LONG_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)LONG_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)LONG_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_ULONG);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)ULONG_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)ULONG_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)ULONG_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)ULONG_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)ULONG_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)ULONG_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_LONGLONG);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)LONGLONG_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)LONGLONG_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)LONGLONG_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)LONGLONG_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)LONGLONG_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)LONGLONG_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_ULONGLONG);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)ULONGLONG_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)ULONGLONG_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)ULONGLONG_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)ULONGLONG_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)ULONGLONG_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)ULONGLONG_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_HALF);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)HALF_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)HALF_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)HALF_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)HALF_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)HALF_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)HALF_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_FLOAT);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)FLOAT_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)FLOAT_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)FLOAT_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)FLOAT_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)FLOAT_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)FLOAT_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_DOUBLE);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)DOUBLE_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)DOUBLE_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)DOUBLE_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)DOUBLE_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)DOUBLE_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)DOUBLE_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_LONGDOUBLE);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)LONGDOUBLE_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)LONGDOUBLE_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)LONGDOUBLE_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)LONGDOUBLE_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)LONGDOUBLE_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)LONGDOUBLE_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_CFLOAT);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)CFLOAT_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)CFLOAT_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)CFLOAT_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)CFLOAT_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)CFLOAT_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)CFLOAT_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_CDOUBLE);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)CDOUBLE_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)CDOUBLE_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)CDOUBLE_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)CDOUBLE_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)CDOUBLE_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)CDOUBLE_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_CLONGDOUBLE);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)CLONGDOUBLE_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)CLONGDOUBLE_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)CLONGDOUBLE_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)CLONGDOUBLE_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)CLONGDOUBLE_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)CLONGDOUBLE_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_STRING);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)STRING_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)STRING_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)STRING_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)STRING_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)STRING_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)STRING_amergesort;
    
#line 985
    descr = PyArray_DescrFromType(PyArray_UNICODE);
    descr->f->sort[PyArray_QUICKSORT] =
        (PyArray_SortFunc *)UNICODE_quicksort;
    descr->f->argsort[PyArray_QUICKSORT] =
        (PyArray_ArgSortFunc *)UNICODE_aquicksort;
    descr->f->sort[PyArray_HEAPSORT] =
        (PyArray_SortFunc *)UNICODE_heapsort;
    descr->f->argsort[PyArray_HEAPSORT] =
        (PyArray_ArgSortFunc *)UNICODE_aheapsort;
    descr->f->sort[PyArray_MERGESORT] =
        (PyArray_SortFunc *)UNICODE_mergesort;
    descr->f->argsort[PyArray_MERGESORT] =
        (PyArray_ArgSortFunc *)UNICODE_amergesort;
    

}

static struct PyMethodDef methods[] = {
    {NULL, NULL, 0, NULL}
};


#if defined(NPY_PY3K)
static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        "_sort",
        NULL,
        -1,
        methods,
        NULL,
        NULL,
        NULL,
        NULL
};
#endif

/* Initialization function for the module */
#if defined(NPY_PY3K)
PyObject *PyInit__sort(void) {
    PyObject *m;
    m = PyModule_Create(&moduledef);
    if (!m) {
        return NULL;
    }
    import_array();
    add_sortfuncs();
    return m;
}
#else
PyMODINIT_FUNC
init_sort(void) {
    Py_InitModule("_sort", methods);

    import_array();
    add_sortfuncs();
}
#endif

