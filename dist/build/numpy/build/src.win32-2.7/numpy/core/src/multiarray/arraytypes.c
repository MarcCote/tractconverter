#line 1 "numpy\\core\\src\\multiarray\\arraytypes.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- c -*- */
#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "datetime.h"
#include "structmember.h"

#define _MULTIARRAYMODULE
#define NPY_NO_PREFIX
#include "numpy/arrayobject.h"
#include "numpy/arrayscalars.h"

#include "numpy/npy_3kcompat.h"

#include "numpy/npy_math.h"
#include "numpy/halffloat.h"

#include "common.h"
#include "ctors.h"
#include "usertypes.h"
#include "npy_config.h"
#include "_datetime.h"

#include "numpyos.h"


/*
 *****************************************************************************
 **                        PYTHON TYPES TO C TYPES                          **
 *****************************************************************************
 */

static double
MyPyFloat_AsDouble(PyObject *obj)
{
    double ret = 0;
    PyObject *num;

    if (obj == Py_None) {
        return NPY_NAN;
    }
    num = PyNumber_Float(obj);
    if (num == NULL) {
        return NPY_NAN;
    }
    ret = PyFloat_AsDouble(num);
    Py_DECREF(num);
    return ret;
}

static npy_half
MyPyFloat_AsHalf(PyObject *obj)
{
    return npy_double_to_half(MyPyFloat_AsDouble(obj));
}

static PyObject *
MyPyFloat_FromHalf(npy_half h)
{
    return PyFloat_FromDouble(npy_half_to_double(h));
}


#line 67
static long
MyPyLong_AsLong (PyObject *obj)
{
    long ret;
    PyObject *num = PyNumber_Long(obj);

    if (num == NULL) {
        return -1;
    }
    ret = PyLong_AsLong(num);
    Py_DECREF(num);
    return ret;
}

static ulong
MyPyLong_AsUnsignedLong (PyObject *obj)
{
    ulong ret;
    PyObject *num = PyNumber_Long(obj);

    if (num == NULL) {
        return -1;
    }
    ret = PyLong_AsUnsignedLong(num);
    if (PyErr_Occurred()) {
        PyErr_Clear();
        ret = PyLong_AsLong(num);
    }
    Py_DECREF(num);
    return ret;
}


#line 67
static longlong
MyPyLong_AsLongLong (PyObject *obj)
{
    longlong ret;
    PyObject *num = PyNumber_Long(obj);

    if (num == NULL) {
        return -1;
    }
    ret = PyLong_AsLongLong(num);
    Py_DECREF(num);
    return ret;
}

static ulonglong
MyPyLong_AsUnsignedLongLong (PyObject *obj)
{
    ulonglong ret;
    PyObject *num = PyNumber_Long(obj);

    if (num == NULL) {
        return -1;
    }
    ret = PyLong_AsUnsignedLongLong(num);
    if (PyErr_Occurred()) {
        PyErr_Clear();
        ret = PyLong_AsLongLong(num);
    }
    Py_DECREF(num);
    return ret;
}




/*
 *****************************************************************************
 **                         GETITEM AND SETITEM                             **
 *****************************************************************************
 */


static char * _SEQUENCE_MESSAGE = "error setting an array element with a sequence";

#line 127
static PyObject *
BOOL_getitem(char *ip, PyArrayObject *ap) {
    Bool t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((Bool *)ip);
        return PyBool_FromLong((long)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyBool_FromLong((long)t1);
    }
}

static int
BOOL_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    Bool temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, Bool)) {
        temp = ((PyBoolScalarObject *)op)->obval;
    }
    else {
        temp = (Bool)PyObject_IsTrue(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((Bool *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
BYTE_getitem(char *ip, PyArrayObject *ap) {
    byte t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((byte *)ip);
        return PyInt_FromLong((long)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyInt_FromLong((long)t1);
    }
}

static int
BYTE_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    byte temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, Byte)) {
        temp = ((PyByteScalarObject *)op)->obval;
    }
    else {
        temp = (byte)MyPyLong_AsLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((byte *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
UBYTE_getitem(char *ip, PyArrayObject *ap) {
    ubyte t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((ubyte *)ip);
        return PyInt_FromLong((long)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyInt_FromLong((long)t1);
    }
}

static int
UBYTE_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    ubyte temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, UByte)) {
        temp = ((PyUByteScalarObject *)op)->obval;
    }
    else {
        temp = (ubyte)MyPyLong_AsLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((ubyte *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
SHORT_getitem(char *ip, PyArrayObject *ap) {
    short t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((short *)ip);
        return PyInt_FromLong((long)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyInt_FromLong((long)t1);
    }
}

static int
SHORT_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    short temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, Short)) {
        temp = ((PyShortScalarObject *)op)->obval;
    }
    else {
        temp = (short)MyPyLong_AsLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((short *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
USHORT_getitem(char *ip, PyArrayObject *ap) {
    ushort t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((ushort *)ip);
        return PyInt_FromLong((long)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyInt_FromLong((long)t1);
    }
}

static int
USHORT_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    ushort temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, UShort)) {
        temp = ((PyUShortScalarObject *)op)->obval;
    }
    else {
        temp = (ushort)MyPyLong_AsLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((ushort *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
INT_getitem(char *ip, PyArrayObject *ap) {
    int t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((int *)ip);
        return PyInt_FromLong((long)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyInt_FromLong((long)t1);
    }
}

static int
INT_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    int temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, Int)) {
        temp = ((PyIntScalarObject *)op)->obval;
    }
    else {
        temp = (int)MyPyLong_AsLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((int *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
LONG_getitem(char *ip, PyArrayObject *ap) {
    long t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((long *)ip);
        return PyInt_FromLong((long)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyInt_FromLong((long)t1);
    }
}

static int
LONG_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    long temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, Long)) {
        temp = ((PyLongScalarObject *)op)->obval;
    }
    else {
        temp = (long)MyPyLong_AsLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((long *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
UINT_getitem(char *ip, PyArrayObject *ap) {
    uint t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((uint *)ip);
        return PyLong_FromUnsignedLong((ulong)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyLong_FromUnsignedLong((ulong)t1);
    }
}

static int
UINT_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    uint temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, UInt)) {
        temp = ((PyUIntScalarObject *)op)->obval;
    }
    else {
        temp = (uint)MyPyLong_AsUnsignedLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((uint *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
ULONG_getitem(char *ip, PyArrayObject *ap) {
    ulong t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((ulong *)ip);
        return PyLong_FromUnsignedLong((ulong)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyLong_FromUnsignedLong((ulong)t1);
    }
}

static int
ULONG_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    ulong temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, ULong)) {
        temp = ((PyULongScalarObject *)op)->obval;
    }
    else {
        temp = (ulong)MyPyLong_AsUnsignedLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((ulong *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
LONGLONG_getitem(char *ip, PyArrayObject *ap) {
    longlong t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((longlong *)ip);
        return PyLong_FromLongLong((longlong)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyLong_FromLongLong((longlong)t1);
    }
}

static int
LONGLONG_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    longlong temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, LongLong)) {
        temp = ((PyLongLongScalarObject *)op)->obval;
    }
    else {
        temp = (longlong)MyPyLong_AsLongLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((longlong *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
ULONGLONG_getitem(char *ip, PyArrayObject *ap) {
    ulonglong t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((ulonglong *)ip);
        return PyLong_FromUnsignedLongLong((ulonglong)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyLong_FromUnsignedLongLong((ulonglong)t1);
    }
}

static int
ULONGLONG_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    ulonglong temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, ULongLong)) {
        temp = ((PyULongLongScalarObject *)op)->obval;
    }
    else {
        temp = (ulonglong)MyPyLong_AsUnsignedLongLong(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((ulonglong *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
HALF_getitem(char *ip, PyArrayObject *ap) {
    npy_half t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((npy_half *)ip);
        return MyPyFloat_FromHalf((npy_half)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return MyPyFloat_FromHalf((npy_half)t1);
    }
}

static int
HALF_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    npy_half temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, Half)) {
        temp = ((PyHalfScalarObject *)op)->obval;
    }
    else {
        temp = (npy_half)MyPyFloat_AsHalf(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((npy_half *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
FLOAT_getitem(char *ip, PyArrayObject *ap) {
    float t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((float *)ip);
        return PyFloat_FromDouble((float)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyFloat_FromDouble((float)t1);
    }
}

static int
FLOAT_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    float temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, Float)) {
        temp = ((PyFloatScalarObject *)op)->obval;
    }
    else {
        temp = (float)MyPyFloat_AsDouble(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((float *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


#line 127
static PyObject *
DOUBLE_getitem(char *ip, PyArrayObject *ap) {
    double t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((double *)ip);
        return PyFloat_FromDouble((double)t1);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyFloat_FromDouble((double)t1);
    }
}

static int
DOUBLE_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    double temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, Double)) {
        temp = ((PyDoubleScalarObject *)op)->obval;
    }
    else {
        temp = (double)MyPyFloat_AsDouble(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                            !PyUnicode_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((double *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}



#line 175
static PyObject *
CFLOAT_getitem(char *ip, PyArrayObject *ap) {
    float t1, t2;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        return PyComplex_FromDoubles((double)((float *)ip)[0],
                (double)((float *)ip)[1]);
    }
    else {
        int size = sizeof(float);
        Bool swap = !PyArray_ISNOTSWAPPED(ap);
        copy_and_swap(&t1, ip, size, 1, 0, swap);
        copy_and_swap(&t2, ip + size, size, 1, 0, swap);
        return PyComplex_FromDoubles((double)t1, (double)t2);
    }
}


#line 175
static PyObject *
CDOUBLE_getitem(char *ip, PyArrayObject *ap) {
    double t1, t2;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        return PyComplex_FromDoubles((double)((double *)ip)[0],
                (double)((double *)ip)[1]);
    }
    else {
        int size = sizeof(double);
        Bool swap = !PyArray_ISNOTSWAPPED(ap);
        copy_and_swap(&t1, ip, size, 1, 0, swap);
        copy_and_swap(&t2, ip + size, size, 1, 0, swap);
        return PyComplex_FromDoubles((double)t1, (double)t2);
    }
}





#line 202
static int
CFLOAT_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    Py_complex oop;
    PyObject *op2;
    cfloat temp;
    int rsize;

    if (!(PyArray_IsScalar(op, CFloat))) {
        if (PyArray_Check(op) && (PyArray_NDIM(op) == 0)) {
            op2 = ((PyArrayObject *)op)->descr->f->getitem
                  (((PyArrayObject *)op)->data, (PyArrayObject *)op);
        }
        else {
            op2 = op; Py_INCREF(op);
        }
        if (op2 == Py_None) {
            oop.real = NPY_NAN;
            oop.imag = NPY_NAN;
        }
        else {
            oop = PyComplex_AsCComplex (op2);
        }
        Py_DECREF(op2);
        if (PyErr_Occurred()) {
            return -1;
        }
        temp.real = (float) oop.real;
        temp.imag = (float) oop.imag;
    }
    else {
        temp = ((PyCFloatScalarObject *)op)->obval;
    }
    memcpy(ov, &temp, ap->descr->elsize);
    if (!PyArray_ISNOTSWAPPED(ap)) {
        byte_swap_vector(ov, 2, sizeof(float));
    }
    rsize = sizeof(float);
    copy_and_swap(ov, &temp, rsize, 2, rsize, !PyArray_ISNOTSWAPPED(ap));
    return 0;
}


#line 202
static int
CDOUBLE_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    Py_complex oop;
    PyObject *op2;
    cdouble temp;
    int rsize;

    if (!(PyArray_IsScalar(op, CDouble))) {
        if (PyArray_Check(op) && (PyArray_NDIM(op) == 0)) {
            op2 = ((PyArrayObject *)op)->descr->f->getitem
                  (((PyArrayObject *)op)->data, (PyArrayObject *)op);
        }
        else {
            op2 = op; Py_INCREF(op);
        }
        if (op2 == Py_None) {
            oop.real = NPY_NAN;
            oop.imag = NPY_NAN;
        }
        else {
            oop = PyComplex_AsCComplex (op2);
        }
        Py_DECREF(op2);
        if (PyErr_Occurred()) {
            return -1;
        }
        temp.real = (double) oop.real;
        temp.imag = (double) oop.imag;
    }
    else {
        temp = ((PyCDoubleScalarObject *)op)->obval;
    }
    memcpy(ov, &temp, ap->descr->elsize);
    if (!PyArray_ISNOTSWAPPED(ap)) {
        byte_swap_vector(ov, 2, sizeof(double));
    }
    rsize = sizeof(double);
    copy_and_swap(ov, &temp, rsize, 2, rsize, !PyArray_ISNOTSWAPPED(ap));
    return 0;
}


#line 202
static int
CLONGDOUBLE_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    Py_complex oop;
    PyObject *op2;
    clongdouble temp;
    int rsize;

    if (!(PyArray_IsScalar(op, CLongDouble))) {
        if (PyArray_Check(op) && (PyArray_NDIM(op) == 0)) {
            op2 = ((PyArrayObject *)op)->descr->f->getitem
                  (((PyArrayObject *)op)->data, (PyArrayObject *)op);
        }
        else {
            op2 = op; Py_INCREF(op);
        }
        if (op2 == Py_None) {
            oop.real = NPY_NAN;
            oop.imag = NPY_NAN;
        }
        else {
            oop = PyComplex_AsCComplex (op2);
        }
        Py_DECREF(op2);
        if (PyErr_Occurred()) {
            return -1;
        }
        temp.real = (longdouble) oop.real;
        temp.imag = (longdouble) oop.imag;
    }
    else {
        temp = ((PyCLongDoubleScalarObject *)op)->obval;
    }
    memcpy(ov, &temp, ap->descr->elsize);
    if (!PyArray_ISNOTSWAPPED(ap)) {
        byte_swap_vector(ov, 2, sizeof(longdouble));
    }
    rsize = sizeof(longdouble);
    copy_and_swap(ov, &temp, rsize, 2, rsize, !PyArray_ISNOTSWAPPED(ap));
    return 0;
}



/*
 * These return array scalars which are different than other date-types.
 */

static PyObject *
LONGDOUBLE_getitem(char *ip, PyArrayObject *ap)
{
    return PyArray_Scalar(ip, ap->descr, NULL);
}

static int
LONGDOUBLE_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    longdouble temp;

    if (PyArray_IsScalar(op, LongDouble)) {
        temp = ((PyLongDoubleScalarObject *)op)->obval;
    }
    else {
        temp = (longdouble) MyPyFloat_AsDouble(op);
    }
    if (PyErr_Occurred()) {
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap)) {
        *((longdouble *)ov) = temp;
    }
    else {
        copy_and_swap(ov, &temp, ap->descr->elsize, 1, 0,
                !PyArray_ISNOTSWAPPED(ap));
    }
    return 0;
}

static PyObject *
CLONGDOUBLE_getitem(char *ip, PyArrayObject *ap)
{
    return PyArray_Scalar(ip, ap->descr, NULL);
}

/* UNICODE */
static PyObject *
UNICODE_getitem(char *ip, PyArrayObject *ap)
{
    Py_ssize_t size = PyArray_ITEMSIZE(ap);
    int swap = !PyArray_ISNOTSWAPPED(ap);
    int align = !PyArray_ISALIGNED(ap);

    return (PyObject *)PyUnicode_FromUCS4(ip, size, swap, align);
}

static int
UNICODE_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    PyObject *temp;
    Py_UNICODE *ptr;
    int datalen;
#ifndef Py_UNICODE_WIDE
    char *buffer;
#endif

    if (!PyBytes_Check(op) && !PyUnicode_Check(op) &&
            PySequence_Check(op) && PySequence_Size(op) > 0) {
        PyErr_SetString(PyExc_ValueError,
                "setting an array element with a sequence");
        return -1;
    }
    /* Sequence_Size might have returned an error */
    if (PyErr_Occurred()) {
        PyErr_Clear();
    }
#if defined(NPY_PY3K)
    if (PyBytes_Check(op)) {
        /* Try to decode from ASCII */
        temp = PyUnicode_FromEncodedObject(op, "ASCII", "strict");
        if (temp == NULL) {
            return -1;
        }
    }
    else if ((temp=PyObject_Str(op)) == NULL) {
#else
    if ((temp=PyObject_Unicode(op)) == NULL) {
#endif
        return -1;
    }
    ptr = PyUnicode_AS_UNICODE(temp);
    if ((ptr == NULL) || (PyErr_Occurred())) {
        Py_DECREF(temp);
        return -1;
    }
    datalen = PyUnicode_GET_DATA_SIZE(temp);

#ifdef Py_UNICODE_WIDE
    memcpy(ov, ptr, MIN(ap->descr->elsize, datalen));
#else
    if (!PyArray_ISALIGNED(ap)) {
        buffer = _pya_malloc(ap->descr->elsize);
        if (buffer == NULL) {
            Py_DECREF(temp);
            PyErr_NoMemory();
            return -1;
        }
    }
    else {
        buffer = ov;
    }
    datalen = PyUCS2Buffer_AsUCS4(ptr, (PyArray_UCS4 *)buffer,
            datalen >> 1, ap->descr->elsize >> 2);
    datalen <<= 2;
    if (!PyArray_ISALIGNED(ap)) {
        memcpy(ov, buffer, datalen);
        _pya_free(buffer);
    }
#endif
    /* Fill in the rest of the space with 0 */
    if (ap->descr->elsize > datalen) {
        memset(ov + datalen, 0, (ap->descr->elsize - datalen));
    }
    if (!PyArray_ISNOTSWAPPED(ap)) {
        byte_swap_vector(ov, ap->descr->elsize >> 2, 4);
    }
    Py_DECREF(temp);
    return 0;
}

/* STRING
 *
 * can handle both NULL-terminated and not NULL-terminated cases
 * will truncate all ending NULLs in returned string.
 */
static PyObject *
STRING_getitem(char *ip, PyArrayObject *ap)
{
    /* Will eliminate NULLs at the end */
    char *ptr;
    int size = ap->descr->elsize;

    ptr = ip + size - 1;
    while (*ptr-- == '\0' && size > 0) {
        size--;
    }
    return PyBytes_FromStringAndSize(ip,size);
}

static int
STRING_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    char *ptr;
    Py_ssize_t len;
    PyObject *temp = NULL;

    /* Handle case of assigning from an array scalar */
    if (PyArray_Check(op) && PyArray_NDIM(op) == 0) {
        temp = PyArray_ToScalar(PyArray_DATA(op), op);
        if (temp == NULL) {
            return -1;
        }
        else {
            int res = STRING_setitem(temp, ov, ap);
            Py_DECREF(temp);
            return res;
        }
    }

    if (!PyBytes_Check(op) && !PyUnicode_Check(op)
            && PySequence_Check(op) && PySequence_Size(op) != 0) {
        PyErr_SetString(PyExc_ValueError,
                "cannot set an array element with a sequence");
        return -1;
    }
#if defined(NPY_PY3K)
    if (PyUnicode_Check(op)) {
        /* Assume ASCII codec -- function similarly as Python 2 */
        temp = PyUnicode_AsASCIIString(op);
        if (temp == NULL) return -1;
    }
    else if (PyBytes_Check(op) || PyMemoryView_Check(op)) {
        temp = PyObject_Bytes(op);
        if (temp == NULL) {
            return -1;
        }
    }
    else {
        /* Emulate similar casting behavior as on Python 2 */
        PyObject *str;
        str = PyObject_Str(op);
        if (str == NULL) {
            return -1;
        }
        temp = PyUnicode_AsASCIIString(str);
        Py_DECREF(str);
        if (temp == NULL) {
            return -1;
        }
    }
#else
    if ((temp = PyObject_Str(op)) == NULL) {
        return -1;
    }
#endif
    if (PyBytes_AsStringAndSize(temp, &ptr, &len) == -1) {
        Py_DECREF(temp);
        return -1;
    }
    memcpy(ov, ptr, MIN(ap->descr->elsize,len));
    /*
     * If string lenth is smaller than room in array
     * Then fill the rest of the element size with NULL
     */
    if (ap->descr->elsize > len) {
        memset(ov + len, 0, (ap->descr->elsize - len));
    }
    Py_DECREF(temp);
    return 0;
}

/* OBJECT */

#define __ALIGNED(obj, sz) ((((size_t) obj) % (sz))==0)

static PyObject *
OBJECT_getitem(char *ip, PyArrayObject *ap)
{
    PyObject *obj;
    NPY_COPY_PYOBJECT_PTR(&obj, ip);
    if (obj == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else {
        Py_INCREF(obj);
        return obj;
    }
}


static int
OBJECT_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    PyObject *obj;

    NPY_COPY_PYOBJECT_PTR(&obj, ov);
    Py_XDECREF(obj);

    Py_INCREF(op);
    NPY_COPY_PYOBJECT_PTR(ov, &op);

    return PyErr_Occurred() ? -1 : 0;
}

/* VOID */

static PyObject *
VOID_getitem(char *ip, PyArrayObject *ap)
{
    PyObject *u = NULL;
    PyArray_Descr* descr;
    int itemsize;

    descr = ap->descr;
    if (descr->names != NULL) {
        PyObject *key;
        PyObject *names;
        int i, n;
        PyObject *ret;
        PyObject *tup, *title;
        PyArray_Descr *new;
        int offset;
        int savedflags;

        /* get the names from the fields dictionary*/
        names = descr->names;
        n = PyTuple_GET_SIZE(names);
        ret = PyTuple_New(n);
        savedflags = ap->flags;
        for (i = 0; i < n; i++) {
            key = PyTuple_GET_ITEM(names, i);
            tup = PyDict_GetItem(descr->fields, key);
            if (!PyArg_ParseTuple(tup, "Oi|O", &new, &offset, &title)) {
                Py_DECREF(ret);
                ap->descr = descr;
                return NULL;
            }
            ap->descr = new;
            /* update alignment based on offset */
            if ((new->alignment > 1)
                    && ((((intp)(ip+offset)) % new->alignment) != 0)) {
                ap->flags &= ~ALIGNED;
            }
            else {
                ap->flags |= ALIGNED;
            }
            PyTuple_SET_ITEM(ret, i, new->f->getitem(ip+offset, ap));
            ap->flags = savedflags;
        }
        ap->descr = descr;
        return ret;
    }

    if (descr->subarray) {
        /* return an array of the basic type */
        PyArray_Dims shape = {NULL, -1};
        PyObject *ret;

        if (!(PyArray_IntpConverter(descr->subarray->shape, &shape))) {
            PyDimMem_FREE(shape.ptr);
            PyErr_SetString(PyExc_ValueError,
                    "invalid shape in fixed-type tuple.");
            return NULL;
        }
        Py_INCREF(descr->subarray->base);
        ret = PyArray_NewFromDescr(&PyArray_Type,
                descr->subarray->base, shape.len, shape.ptr,
                NULL, ip, ap->flags&(~NPY_F_CONTIGUOUS), NULL);
        PyDimMem_FREE(shape.ptr);
        if (!ret) {
            return NULL;
        }
        PyArray_BASE(ret) = (PyObject *)ap;
        Py_INCREF(ap);
        PyArray_UpdateFlags((PyArrayObject *)ret, UPDATE_ALL);
        return ret;
    }

    if (PyDataType_FLAGCHK(descr, NPY_ITEM_HASOBJECT)
            || PyDataType_FLAGCHK(descr, NPY_ITEM_IS_POINTER)) {
        PyErr_SetString(PyExc_ValueError,
                "tried to get void-array with object members as buffer.");
        return NULL;
    }
    itemsize = ap->descr->elsize;
#if defined(NPY_PY3K)
    /*
     * Return a byte array; there are no plain buffer objects on Py3
     */
    {
        intp dims[1], strides[1];
        PyArray_Descr *descr;
        dims[0] = itemsize;
        strides[0] = 1;
        descr = PyArray_DescrNewFromType(PyArray_BYTE);
        u = PyArray_NewFromDescr(&PyArray_Type, descr, 1, dims, strides,
                                 ip,
                                 PyArray_ISWRITEABLE(ap) ? NPY_WRITEABLE : 0,
                                 NULL);
        ((PyArrayObject*)u)->base = ap;
        Py_INCREF(ap);
    }
#else
    /*
     * default is to return buffer object pointing to
     * current item a view of it
     */
    if (PyArray_ISWRITEABLE(ap)) {
        u = PyBuffer_FromReadWriteMemory(ip, itemsize);
    }
    else {
        u = PyBuffer_FromMemory(ip, itemsize);
    }
#endif
    if (u == NULL) {
        goto fail;
    }
    return u;

fail:
    return NULL;
}


NPY_NO_EXPORT int PyArray_CopyObject(PyArrayObject *, PyObject *);

static int
VOID_setitem(PyObject *op, char *ip, PyArrayObject *ap)
{
    PyArray_Descr* descr;
    int itemsize=ap->descr->elsize;
    int res;

    descr = ap->descr;
    if (descr->names && PyTuple_Check(op)) {
        PyObject *key;
        PyObject *names;
        int i, n;
        PyObject *tup, *title;
        PyArray_Descr *new;
        int offset;
        int savedflags;

        res = -1;
        /* get the names from the fields dictionary*/
        names = descr->names;
        n = PyTuple_GET_SIZE(names);
        if (PyTuple_GET_SIZE(op) != n) {
            PyErr_SetString(PyExc_ValueError,
                    "size of tuple must match number of fields.");
            return -1;
        }
        savedflags = ap->flags;
        for (i = 0; i < n; i++) {
            key = PyTuple_GET_ITEM(names, i);
            tup = PyDict_GetItem(descr->fields, key);
            if (!PyArg_ParseTuple(tup, "Oi|O", &new, &offset, &title)) {
                ap->descr = descr;
                return -1;
            }
            ap->descr = new;
            /* remember to update alignment flags */
            if ((new->alignment > 1)
                    && ((((intp)(ip+offset)) % new->alignment) != 0)) {
                ap->flags &= ~ALIGNED;
            }
            else {
                ap->flags |= ALIGNED;
            }
            res = new->f->setitem(PyTuple_GET_ITEM(op, i), ip+offset, ap);
            ap->flags = savedflags;
            if (res < 0) {
                break;
            }
        }
        ap->descr = descr;
        return res;
    }

    if (descr->subarray) {
        /* copy into an array of the same basic type */
        PyArray_Dims shape = {NULL, -1};
        PyObject *ret;
        if (!(PyArray_IntpConverter(descr->subarray->shape, &shape))) {
            PyDimMem_FREE(shape.ptr);
            PyErr_SetString(PyExc_ValueError,
                    "invalid shape in fixed-type tuple.");
            return -1;
        }
        Py_INCREF(descr->subarray->base);
        ret = PyArray_NewFromDescr(&PyArray_Type,
                descr->subarray->base, shape.len, shape.ptr,
                NULL, ip, ap->flags, NULL);
        PyDimMem_FREE(shape.ptr);
        if (!ret) {
            return -1;
        }
        PyArray_BASE(ret) = (PyObject *)ap;
        Py_INCREF(ap);
        PyArray_UpdateFlags((PyArrayObject *)ret, UPDATE_ALL);
        res = PyArray_CopyObject((PyArrayObject *)ret, op);
        Py_DECREF(ret);
        return res;
    }

    /* Default is to use buffer interface to set item */
    {
        const void *buffer;
        Py_ssize_t buflen;
        if (PyDataType_FLAGCHK(descr, NPY_ITEM_HASOBJECT)
                || PyDataType_FLAGCHK(descr, NPY_ITEM_IS_POINTER)) {
            PyErr_SetString(PyExc_ValueError,
                    "Setting void-array with object members using buffer.");
            return -1;
        }
        res = PyObject_AsReadBuffer(op, &buffer, &buflen);
        if (res == -1) {
            goto fail;
        }
        memcpy(ip, buffer, NPY_MIN(buflen, itemsize));
        if (itemsize > buflen) {
            memset(ip + buflen, 0, itemsize - buflen);
        }
    }
    return 0;

fail:
    return -1;
}

/*
 * Acknowledgement:  Example code contributed by Marty Fuhr sponsored by
 * Google Summer of Code 2009 was used to integrate and adapt the mxDateTime
 * parser
 */

/* #include "datetime.c" --- now included in multiarray_onefile */


/* DateTime Objects in Python only keep microsecond resolution.
 *
 * When converting from datetime objects with an event component return a
 * tuple: * (baseunit, number of event)  where baseunit follows is a datetime
 * type and number of events is a Python integer
 */


/*
 * Return a Python Datetime Object from a number representing the number of
 * units since the epoch (1970-01-01T00:00:00Z) ignoring leap seconds.
 */

NPY_NO_EXPORT PyObject *
PyDateTime_FromNormalized(npy_datetime val, NPY_DATETIMEUNIT base)
{
    npy_datetimestruct ydate;

    /* Must be here to use PyDateTime_FromDateAndTime */
    PyDateTime_IMPORT;

    /* We just truncate the unused variables and don't wory about overflow */
    PyArray_DatetimeToDatetimeStruct(val, base, &ydate);

    /* FIXME?: We discard ydate.ns, ydate.ps, ydate.fs, and ydate.as */
    return PyDateTime_FromDateAndTime(ydate.year, ydate.month, ydate.day,
                                      ydate.hour, ydate.min, ydate.sec,
                                      ydate.us);
}

/*
 * We also can lose precision and range here.  Ignored.
 * Don't use this function if you care.
 */

NPY_NO_EXPORT PyObject *
PyTimeDelta_FromNormalized(npy_timedelta val, NPY_DATETIMEUNIT base)
{
    npy_timedeltastruct td;

    PyDateTime_IMPORT;
    PyArray_TimedeltaToTimedeltaStruct(val, base, &td);

    /* We discard td.ps and td.as */
    return PyDelta_FromDSU(td.day, td.sec, td.us);
}


NPY_NO_EXPORT PyObject *
PyDateTime_FromInt64(datetime val, PyArray_Descr *descr)
{
    PyArray_DatetimeMetaData *meta;

    meta = PyDataType_GetDatetimeMetaData(descr);
    if (meta == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                "metadata not set for descriptor");
        return NULL;
    }

    if (meta->events > 1) {
        int events, rem, div;
        PyObject *obj;

        obj = PyTuple_New(2);
        events = meta->events;
        div = val/events;
        rem = val % events;
        PyTuple_SET_ITEM(obj, 1, PyInt_FromLong(rem));
        /* This resets meta->events for recursive call */
        meta->events = 1;
        PyTuple_SET_ITEM(obj, 0, PyDateTime_FromInt64(div, descr));
        meta->events = events;
        if (PyErr_Occurred()) {
            Py_DECREF(obj);
            return NULL;
        }
        return obj;
    }

    /*
     * We normalize the number to a base-unit and then return a
     * Python Datetime Object
     *
     * FIXME? : We silently truncate if it doesn't fit, either too
     *  wide (e.g. 10 BC) or too narrow (nanoseconds)
     */

    /* Normalization and then conversion to Datetime */
    /* FIXME? : Check for Overflow... */
    return PyDateTime_FromNormalized(val*meta->num, meta->base);
}


NPY_NO_EXPORT PyObject *
PyTimeDelta_FromInt64(timedelta val, PyArray_Descr *descr)
{
    PyArray_DatetimeMetaData *meta;
    meta = PyDataType_GetDatetimeMetaData(descr);
    if (meta == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                "metadata not set for descriptor");
        return NULL;
    }

    if (meta->events > 1) {
        int events, rem, div;
        PyObject *obj;

        obj = PyTuple_New(2);
        events = meta->events;
        div = val/events;
        rem = val % events;
        PyTuple_SET_ITEM(obj, 1, PyInt_FromLong(rem));
        /* This resets meta->events for recursive call */
        meta->events = 1;
        PyTuple_SET_ITEM(obj, 0, PyTimeDelta_FromInt64(div, descr));
        meta->events = events;
        if (PyErr_Occurred()) {
            Py_DECREF(obj);
            return NULL;
        }
        return obj;
    }

    /* FIXME? : Check for Overflow */
    return PyTimeDelta_FromNormalized(val*meta->num, meta->base);
}



NPY_NO_EXPORT npy_datetime
PyDateTime_AsNormalized(PyObject *obj, NPY_DATETIMEUNIT base)
{
    npy_datetimestruct ydate;

    /* Must be here to use PyDateTime_FromDateAndTime */
    PyDateTime_IMPORT;

    if (!PyDateTime_Check(obj) && !PyDate_Check(obj)) {
        PyErr_SetString(PyExc_ValueError,
                "Must be a datetime.date or datetime.datetime object");
        return -1;
    }

    ydate.year = PyDateTime_GET_YEAR(obj);
    ydate.month = PyDateTime_GET_MONTH(obj);
    ydate.day = PyDateTime_GET_DAY(obj);

    if (PyDateTime_Check(obj)) {
        ydate.hour = PyDateTime_DATE_GET_HOUR(obj);
        ydate.min = PyDateTime_DATE_GET_MINUTE(obj);
        ydate.sec = PyDateTime_DATE_GET_SECOND(obj);
        ydate.us = PyDateTime_DATE_GET_MICROSECOND(obj);
    }
    else {
        ydate.hour = 0;
        ydate.min = 0;
        ydate.sec = 0;
        ydate.us = 0;
    }

    ydate.ps = 0;
    ydate.as = 0;

    /* We just truncate the unused variables and don't wory about overflow */
    return PyArray_DatetimeStructToDatetime(base, &ydate);
}

NPY_NO_EXPORT npy_timedelta
PyTimeDelta_AsNormalized(PyObject *obj, NPY_DATETIMEUNIT base)
{
    npy_timedeltastruct td;

    PyDateTime_IMPORT;

    if (!PyDelta_Check(obj)) {
        PyErr_SetString(PyExc_ValueError,
                "Must be a datetime.timedelta object");
        return -1;
    }

    td.day = ((PyDateTime_Delta *)obj)->days;
    td.sec = ((PyDateTime_Delta *)obj)->seconds;
    td.us  = ((PyDateTime_Delta *)obj)->microseconds;
    td.ps  = 0;
    td.as  = 0;

    return PyArray_TimedeltaStructToTimedelta(base, &td);
}


/*
 * These expect a 2-tuple if meta->events > 1  (baseobj, num-counts)
 * where baseobj is a datetime object or a timedelta object respectively.
 *
 */

NPY_NO_EXPORT npy_datetime
PyDateTime_AsInt64(PyObject *obj, PyArray_Descr *descr)
{
    PyArray_DatetimeMetaData *meta;
    npy_datetime res;

    meta = PyDataType_GetDatetimeMetaData(descr);
    if (meta == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                "metadata not set for descriptor");
        return -1;
    }


    if (meta->events > 1) {
        datetime tmp;
        int events;

        if (!PyTuple_Check(obj) || PyTuple_GET_SIZE(obj) != 2) {
            PyErr_SetString(PyExc_ValueError,
                    "need a 2-tuple on setting if events > 1");
            return -1;
        }
        /* Alter the dictionary and call again */
        /* FIXME:  not thread safe */
        events = meta->events;
        meta->events = 1;
        tmp = PyDateTime_AsInt64(PyTuple_GET_ITEM(obj, 0), descr);
        meta->events = events;
        if (PyErr_Occurred()) {
            return -1;
        }
        /* FIXME: Check for overflow */
        tmp *= events;
        tmp += MyPyLong_AsLongLong(PyTuple_GET_ITEM(obj, 1));
        if (PyErr_Occurred()) {
            return -1;
        }
        return tmp;
    }

    res = PyDateTime_AsNormalized(obj, meta->base);
    return res/meta->num;
}


NPY_NO_EXPORT timedelta
PyTimeDelta_AsInt64(PyObject *obj, PyArray_Descr *descr)
{
    PyArray_DatetimeMetaData *meta;
    npy_timedelta res;

    meta = PyDataType_GetDatetimeMetaData(descr);
    if (meta == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                "metadata not set for descriptor");
        return -1;
    }

    if (meta->events > 1) {
        timedelta tmp;
        int events;

        if (!PyTuple_Check(obj) || PyTuple_GET_SIZE(obj) != 2) {
            PyErr_SetString(PyExc_ValueError,
                    "need a 2-tuple on setting if events > 1");
            return -1;
        }
        /* Alter the dictionary and call again (not thread safe) */
        events = meta->events;
        meta->events = 1;
        tmp = PyTimeDelta_AsInt64(PyTuple_GET_ITEM(obj, 0), descr);
        meta->events = events;
        if (PyErr_Occurred()) {
            return -1;
        }
        /* FIXME: Check for overflow */
        tmp *= events;
        tmp += MyPyLong_AsLongLong(PyTuple_GET_ITEM(obj, 1));
        if (PyErr_Occurred()) {
            return -1;
        }
        return tmp;
    }

    res = PyTimeDelta_AsNormalized(obj, meta->base);
    return res / meta->num;
}


/*
 * Always return DateTime Object after normalizing to basic units (or a tuple
 * if meta->events > 1):
 *
 *  Problem:  DateTime does not support all the resolutions (ns) nor the
 *  dynamic range (pre 1 AD) of NumPy Date-times.
 *
 * getitem is not used that much --- if losing resolution hurts, stick
 * with the array scalar versions of the date-time.
 *
 * considered returning array scalars here just like longdouble. This has the
 * problem of recursion in some cases (because in a few places the code
 * expects getitem to return a Python-system object)
 *
 * considered returning different things depending on the resolution but this
 * would make it hard to write generic code  --- but do you need to write
 * generic code on all the frequencies because they cover a wide range.
 *
 * Solution:  The use-case of actually wanting a date-time object when the
 * resolution and dynamic range match, make it the compelling default. When it
 * does fails, there are alternatives for the programmer to use.
 *
 * New question: Should we change (c)longdouble at this point? to return Python Float?
 */

static PyObject *
DATETIME_getitem(char *ip, PyArrayObject *ap) {
    datetime t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((datetime *)ip);
        return PyDateTime_FromInt64((datetime)t1, ap->descr);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyDateTime_FromInt64((datetime)t1, ap->descr);
    }
}


static PyObject *
TIMEDELTA_getitem(char *ip, PyArrayObject *ap) {
    timedelta t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((timedelta *)ip);
        return PyTimeDelta_FromInt64((timedelta)t1, ap->descr);
    }
    else {
        ap->descr->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyTimeDelta_FromInt64((timedelta)t1, ap->descr);
    }
}

/* FIXME:
 *  This needs to take
 *      1) Integers and Longs (anything that can be converted to an Int)
 *      2) Strings (ISO-style dates)
 *      3) Datetime Scalars (that it converts based on scalar dtype.
 *      4) Datetime and Date objects
 *  Plus a tuple for meta->events > 1
 *
 *      3) is partially implemented, 4) is implemented
 */

static int
DATETIME_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    datetime temp;

    if (PyArray_IsScalar(op, Datetime)) {
        /* This needs to convert based on type */
        temp = ((PyDatetimeScalarObject *)op)->obval;
    }
#if defined(NPY_PY3K)
    else if (PyUString_Check(op)) {
#else
    else if (PyUString_Check(op) || PyUnicode_Check(op)) {
#endif
        /* FIXME:  Converts to DateTime first and therefore does not handle extended notation */
        /* import _mx_datetime_parser
         * res = _mx_datetime_parser(name)
         *  Convert from datetime to Int
         */
        PyObject *res, *module;

        module = PyImport_ImportModule("numpy.core._mx_datetime_parser");
        if (module == NULL) { return -1; }
        res = PyObject_CallMethod(module, "datetime_from_string", "O", op);
        Py_DECREF(module);
        if (res == NULL) { return -1; }
        temp = PyDateTime_AsInt64(res, ap->descr);
        Py_DECREF(res);
        if (PyErr_Occurred()) return -1;
    }
    else if (PyInt_Check(op)) {
        temp = PyInt_AS_LONG(op);
    }
    else if (PyLong_Check(op)) {
        temp = PyLong_AsLongLong(op);
    }
    else {
        temp = PyDateTime_AsInt64(op, ap->descr);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, _SEQUENCE_MESSAGE);
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((datetime *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}

/* FIXME: This needs to take
 *    1) Integers and Longs (anything that can be converted to an Int)
 *    2) Timedelta scalar objects (with resolution conversion)
 *    3) Python Timedelta objects
 *
 *    Plus a tuple for meta->events > 1
 */

static int
TIMEDELTA_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    timedelta temp;

    if (PyArray_IsScalar(op, Timedelta)) {
        temp = ((PyTimedeltaScalarObject *)op)->obval;
    }
    else if (PyInt_Check(op)) {
        temp = PyInt_AS_LONG(op);
    }
    else if (PyLong_Check(op)) {
        temp = PyLong_AsLongLong(op);
    }
    else {
        temp = PyTimeDelta_AsInt64(op, ap->descr);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, _SEQUENCE_MESSAGE);
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((timedelta *)ov)=temp;
    else {
        ap->descr->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


/*
 *****************************************************************************
 **                       TYPE TO TYPE CONVERSIONS                          **
 *****************************************************************************
 */


/* Assumes contiguous, and aligned, from and to */


#line 1198

#line 1208
static void
BYTE_to_BYTE(byte *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
UBYTE_to_BYTE(ubyte *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
SHORT_to_BYTE(short *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
USHORT_to_BYTE(ushort *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
INT_to_BYTE(int *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
UINT_to_BYTE(uint *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
LONG_to_BYTE(long *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
ULONG_to_BYTE(ulong *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_BYTE(longlong *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_BYTE(ulonglong *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
FLOAT_to_BYTE(float *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_BYTE(double *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_BYTE(longdouble *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
DATETIME_to_BYTE(datetime *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_BYTE(timedelta *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_BYTE(float *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_BYTE(double *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_BYTE(longdouble *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_UBYTE(byte *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
UBYTE_to_UBYTE(ubyte *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
SHORT_to_UBYTE(short *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
USHORT_to_UBYTE(ushort *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
INT_to_UBYTE(int *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
UINT_to_UBYTE(uint *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
LONG_to_UBYTE(long *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
ULONG_to_UBYTE(ulong *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_UBYTE(longlong *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_UBYTE(ulonglong *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
FLOAT_to_UBYTE(float *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_UBYTE(double *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_UBYTE(longdouble *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
DATETIME_to_UBYTE(datetime *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_UBYTE(timedelta *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_UBYTE(float *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_UBYTE(double *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_UBYTE(longdouble *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_SHORT(byte *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
UBYTE_to_SHORT(ubyte *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
SHORT_to_SHORT(short *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
USHORT_to_SHORT(ushort *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
INT_to_SHORT(int *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
UINT_to_SHORT(uint *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
LONG_to_SHORT(long *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
ULONG_to_SHORT(ulong *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_SHORT(longlong *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_SHORT(ulonglong *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
FLOAT_to_SHORT(float *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_SHORT(double *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_SHORT(longdouble *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
DATETIME_to_SHORT(datetime *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_SHORT(timedelta *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_SHORT(float *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_SHORT(double *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_SHORT(longdouble *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_USHORT(byte *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
UBYTE_to_USHORT(ubyte *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
SHORT_to_USHORT(short *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
USHORT_to_USHORT(ushort *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
INT_to_USHORT(int *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
UINT_to_USHORT(uint *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
LONG_to_USHORT(long *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
ULONG_to_USHORT(ulong *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_USHORT(longlong *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_USHORT(ulonglong *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
FLOAT_to_USHORT(float *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_USHORT(double *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_USHORT(longdouble *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
DATETIME_to_USHORT(datetime *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_USHORT(timedelta *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_USHORT(float *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_USHORT(double *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_USHORT(longdouble *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_INT(byte *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
UBYTE_to_INT(ubyte *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
SHORT_to_INT(short *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
USHORT_to_INT(ushort *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
INT_to_INT(int *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
UINT_to_INT(uint *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
LONG_to_INT(long *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
ULONG_to_INT(ulong *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_INT(longlong *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_INT(ulonglong *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
FLOAT_to_INT(float *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_INT(double *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_INT(longdouble *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
DATETIME_to_INT(datetime *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_INT(timedelta *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_INT(float *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_INT(double *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_INT(longdouble *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_UINT(byte *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
UBYTE_to_UINT(ubyte *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
SHORT_to_UINT(short *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
USHORT_to_UINT(ushort *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
INT_to_UINT(int *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
UINT_to_UINT(uint *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
LONG_to_UINT(long *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
ULONG_to_UINT(ulong *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_UINT(longlong *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_UINT(ulonglong *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
FLOAT_to_UINT(float *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_UINT(double *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_UINT(longdouble *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
DATETIME_to_UINT(datetime *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_UINT(timedelta *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_UINT(float *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_UINT(double *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_UINT(longdouble *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_LONG(byte *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
UBYTE_to_LONG(ubyte *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
SHORT_to_LONG(short *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
USHORT_to_LONG(ushort *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
INT_to_LONG(int *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
UINT_to_LONG(uint *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
LONG_to_LONG(long *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
ULONG_to_LONG(ulong *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_LONG(longlong *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_LONG(ulonglong *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
FLOAT_to_LONG(float *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_LONG(double *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_LONG(longdouble *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
DATETIME_to_LONG(datetime *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_LONG(timedelta *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_LONG(float *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_LONG(double *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_LONG(longdouble *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_ULONG(byte *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
UBYTE_to_ULONG(ubyte *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
SHORT_to_ULONG(short *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
USHORT_to_ULONG(ushort *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
INT_to_ULONG(int *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
UINT_to_ULONG(uint *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
LONG_to_ULONG(long *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
ULONG_to_ULONG(ulong *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_ULONG(longlong *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_ULONG(ulonglong *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
FLOAT_to_ULONG(float *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_ULONG(double *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_ULONG(longdouble *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
DATETIME_to_ULONG(datetime *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_ULONG(timedelta *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_ULONG(float *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_ULONG(double *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_ULONG(longdouble *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_LONGLONG(byte *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
UBYTE_to_LONGLONG(ubyte *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
SHORT_to_LONGLONG(short *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
USHORT_to_LONGLONG(ushort *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
INT_to_LONGLONG(int *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
UINT_to_LONGLONG(uint *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
LONG_to_LONGLONG(long *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
ULONG_to_LONGLONG(ulong *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_LONGLONG(longlong *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_LONGLONG(ulonglong *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
FLOAT_to_LONGLONG(float *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_LONGLONG(double *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_LONGLONG(longdouble *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
DATETIME_to_LONGLONG(datetime *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_LONGLONG(timedelta *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_LONGLONG(float *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_LONGLONG(double *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_LONGLONG(longdouble *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_ULONGLONG(byte *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
UBYTE_to_ULONGLONG(ubyte *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
SHORT_to_ULONGLONG(short *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
USHORT_to_ULONGLONG(ushort *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
INT_to_ULONGLONG(int *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
UINT_to_ULONGLONG(uint *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
LONG_to_ULONGLONG(long *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
ULONG_to_ULONGLONG(ulong *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_ULONGLONG(longlong *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_ULONGLONG(ulonglong *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
FLOAT_to_ULONGLONG(float *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_ULONGLONG(double *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_ULONGLONG(longdouble *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
DATETIME_to_ULONGLONG(datetime *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_ULONGLONG(timedelta *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_ULONGLONG(float *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_ULONGLONG(double *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_ULONGLONG(longdouble *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_FLOAT(byte *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
UBYTE_to_FLOAT(ubyte *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
SHORT_to_FLOAT(short *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
USHORT_to_FLOAT(ushort *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
INT_to_FLOAT(int *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
UINT_to_FLOAT(uint *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
LONG_to_FLOAT(long *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
ULONG_to_FLOAT(ulong *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_FLOAT(longlong *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_FLOAT(ulonglong *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
FLOAT_to_FLOAT(float *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_FLOAT(double *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_FLOAT(longdouble *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
DATETIME_to_FLOAT(datetime *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_FLOAT(timedelta *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_FLOAT(float *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_FLOAT(double *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_FLOAT(longdouble *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_DOUBLE(byte *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
UBYTE_to_DOUBLE(ubyte *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
SHORT_to_DOUBLE(short *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
USHORT_to_DOUBLE(ushort *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
INT_to_DOUBLE(int *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
UINT_to_DOUBLE(uint *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
LONG_to_DOUBLE(long *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
ULONG_to_DOUBLE(ulong *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_DOUBLE(longlong *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_DOUBLE(ulonglong *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
FLOAT_to_DOUBLE(float *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_DOUBLE(double *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_DOUBLE(longdouble *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
DATETIME_to_DOUBLE(datetime *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_DOUBLE(timedelta *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_DOUBLE(float *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_DOUBLE(double *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_DOUBLE(longdouble *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_LONGDOUBLE(byte *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
UBYTE_to_LONGDOUBLE(ubyte *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
SHORT_to_LONGDOUBLE(short *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
USHORT_to_LONGDOUBLE(ushort *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
INT_to_LONGDOUBLE(int *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
UINT_to_LONGDOUBLE(uint *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
LONG_to_LONGDOUBLE(long *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
ULONG_to_LONGDOUBLE(ulong *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_LONGDOUBLE(longlong *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_LONGDOUBLE(ulonglong *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
FLOAT_to_LONGDOUBLE(float *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_LONGDOUBLE(double *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_LONGDOUBLE(longdouble *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
DATETIME_to_LONGDOUBLE(datetime *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_LONGDOUBLE(timedelta *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_LONGDOUBLE(float *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_LONGDOUBLE(double *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_LONGDOUBLE(longdouble *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_DATETIME(byte *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
UBYTE_to_DATETIME(ubyte *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
SHORT_to_DATETIME(short *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
USHORT_to_DATETIME(ushort *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
INT_to_DATETIME(int *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
UINT_to_DATETIME(uint *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
LONG_to_DATETIME(long *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
ULONG_to_DATETIME(ulong *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_DATETIME(longlong *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_DATETIME(ulonglong *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
FLOAT_to_DATETIME(float *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_DATETIME(double *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_DATETIME(longdouble *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
DATETIME_to_DATETIME(datetime *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_DATETIME(timedelta *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_DATETIME(float *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_DATETIME(double *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_DATETIME(longdouble *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)*ip;
        ip += 2;
    }
}



#line 1198

#line 1208
static void
BYTE_to_TIMEDELTA(byte *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
UBYTE_to_TIMEDELTA(ubyte *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
SHORT_to_TIMEDELTA(short *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
USHORT_to_TIMEDELTA(ushort *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
INT_to_TIMEDELTA(int *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
UINT_to_TIMEDELTA(uint *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
LONG_to_TIMEDELTA(long *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
ULONG_to_TIMEDELTA(ulong *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
LONGLONG_to_TIMEDELTA(longlong *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
ULONGLONG_to_TIMEDELTA(ulonglong *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
FLOAT_to_TIMEDELTA(float *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
DOUBLE_to_TIMEDELTA(double *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
LONGDOUBLE_to_TIMEDELTA(longdouble *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
DATETIME_to_TIMEDELTA(datetime *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}

#line 1208
static void
TIMEDELTA_to_TIMEDELTA(timedelta *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip++;
    }
}


#line 1223
static void
CFLOAT_to_TIMEDELTA(float *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip;
        ip += 2;
    }
}

#line 1223
static void
CDOUBLE_to_TIMEDELTA(double *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip;
        ip += 2;
    }
}

#line 1223
static void
CLONGDOUBLE_to_TIMEDELTA(longdouble *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)*ip;
        ip += 2;
    }
}





#line 1246

static void
BYTE_to_HALF(byte *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_BYTE(npy_half *ip, byte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
UBYTE_to_HALF(ubyte *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_UBYTE(npy_half *ip, ubyte *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
SHORT_to_HALF(short *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_SHORT(npy_half *ip, short *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
USHORT_to_HALF(ushort *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_USHORT(npy_half *ip, ushort *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
INT_to_HALF(int *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_INT(npy_half *ip, int *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
UINT_to_HALF(uint *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_UINT(npy_half *ip, uint *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
LONG_to_HALF(long *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_LONG(npy_half *ip, long *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
ULONG_to_HALF(ulong *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_ULONG(npy_half *ip, ulong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
LONGLONG_to_HALF(longlong *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_LONGLONG(npy_half *ip, longlong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
ULONGLONG_to_HALF(ulonglong *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_ULONGLONG(npy_half *ip, ulonglong *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
LONGDOUBLE_to_HALF(longdouble *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_LONGDOUBLE(npy_half *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
DATETIME_to_HALF(datetime *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_DATETIME(npy_half *ip, datetime *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)npy_half_to_float(*ip++);
    }
}


#line 1246

static void
TIMEDELTA_to_HALF(timedelta *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_TIMEDELTA(npy_half *ip, timedelta *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)npy_half_to_float(*ip++);
    }
}


#if SIZEOF_SHORT == 2
#define HALF_to_HALF SHORT_to_SHORT
#elif SIZEOF_INT == 2
#define HALF_to_HALF INT_to_INT
#endif

#line 1279

static void
FLOAT_to_HALF(npy_uint32 *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_floatbits_to_halfbits(*ip);
#if 0
        ip += 2;
#else
        ip++;
#endif
    }
}

static void
HALF_to_FLOAT(npy_half *ip, npy_uint32 *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_halfbits_to_floatbits(*ip++);
#if 0
        *op++ = 0;
#endif
    }
}


#line 1279

static void
DOUBLE_to_HALF(npy_uint64 *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_doublebits_to_halfbits(*ip);
#if 0
        ip += 2;
#else
        ip++;
#endif
    }
}

static void
HALF_to_DOUBLE(npy_half *ip, npy_uint64 *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_halfbits_to_doublebits(*ip++);
#if 0
        *op++ = 0;
#endif
    }
}


#line 1279

static void
CFLOAT_to_HALF(npy_uint32 *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_floatbits_to_halfbits(*ip);
#if 1
        ip += 2;
#else
        ip++;
#endif
    }
}

static void
HALF_to_CFLOAT(npy_half *ip, npy_uint32 *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_halfbits_to_floatbits(*ip++);
#if 1
        *op++ = 0;
#endif
    }
}


#line 1279

static void
CDOUBLE_to_HALF(npy_uint64 *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_doublebits_to_halfbits(*ip);
#if 1
        ip += 2;
#else
        ip++;
#endif
    }
}

static void
HALF_to_CDOUBLE(npy_half *ip, npy_uint64 *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_halfbits_to_doublebits(*ip++);
#if 1
        *op++ = 0;
#endif
    }
}



static void
CLONGDOUBLE_to_HALF(longdouble *ip, npy_half *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_double_to_half((double) (*ip++));
        ip += 2;
    }
}

static void
HALF_to_CLONGDOUBLE(npy_half *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_half_to_double(*ip++);
        *op++ = 0;
    }
}

#line 1337
static void
BOOL_to_BOOL(Bool *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
BYTE_to_BOOL(byte *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
UBYTE_to_BOOL(ubyte *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
SHORT_to_BOOL(short *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
USHORT_to_BOOL(ushort *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
INT_to_BOOL(int *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
UINT_to_BOOL(uint *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
LONG_to_BOOL(long *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
ULONG_to_BOOL(ulong *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
LONGLONG_to_BOOL(longlong *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
ULONGLONG_to_BOOL(ulonglong *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
FLOAT_to_BOOL(float *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
DOUBLE_to_BOOL(double *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
LONGDOUBLE_to_BOOL(longdouble *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
DATETIME_to_BOOL(datetime *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}

#line 1337
static void
TIMEDELTA_to_BOOL(timedelta *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(*ip++ != FALSE);
    }
}


static void
HALF_to_BOOL(npy_half *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (Bool)(!npy_half_iszero(*ip++));
    }
}

#line 1361
static void
CFLOAT_to_BOOL(cfloat *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op = (Bool)(((*ip).real != FALSE) || ((*ip).imag != FALSE));
        op++;
        ip++;
    }
}

#line 1361
static void
CDOUBLE_to_BOOL(cdouble *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op = (Bool)(((*ip).real != FALSE) || ((*ip).imag != FALSE));
        op++;
        ip++;
    }
}

#line 1361
static void
CLONGDOUBLE_to_BOOL(clongdouble *ip, Bool *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op = (Bool)(((*ip).real != FALSE) || ((*ip).imag != FALSE));
        op++;
        ip++;
    }
}


#line 1383
static void
BOOL_to_BYTE(Bool *ip, byte *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (byte)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_UBYTE(Bool *ip, ubyte *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ubyte)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_SHORT(Bool *ip, short *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (short)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_USHORT(Bool *ip, ushort *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ushort)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_INT(Bool *ip, int *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (int)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_UINT(Bool *ip, uint *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (uint)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_LONG(Bool *ip, long *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (long)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_ULONG(Bool *ip, ulong *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulong)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_LONGLONG(Bool *ip, longlong *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longlong)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_ULONGLONG(Bool *ip, ulonglong *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (ulonglong)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_HALF(Bool *ip, npy_half *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (npy_half)((*ip++ != FALSE) ? NPY_HALF_ONE : NPY_HALF_ZERO);
    }
}

#line 1383
static void
BOOL_to_FLOAT(Bool *ip, float *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_DOUBLE(Bool *ip, double *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_LONGDOUBLE(Bool *ip, longdouble *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_DATETIME(Bool *ip, datetime *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (datetime)((*ip++ != FALSE) ? 1 : 0);
    }
}

#line 1383
static void
BOOL_to_TIMEDELTA(Bool *ip, timedelta *op, intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (timedelta)((*ip++ != FALSE) ? 1 : 0);
    }
}


#line 1398

#line 1407
static void
BOOL_to_CFLOAT(Bool *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
BYTE_to_CFLOAT(byte *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
UBYTE_to_CFLOAT(ubyte *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
SHORT_to_CFLOAT(short *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
USHORT_to_CFLOAT(ushort *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
INT_to_CFLOAT(int *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
UINT_to_CFLOAT(uint *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONG_to_CFLOAT(long *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
ULONG_to_CFLOAT(ulong *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONGLONG_to_CFLOAT(longlong *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
ULONGLONG_to_CFLOAT(ulonglong *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
FLOAT_to_CFLOAT(float *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
DOUBLE_to_CFLOAT(double *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONGDOUBLE_to_CFLOAT(longdouble *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
DATETIME_to_CFLOAT(datetime *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
TIMEDELTA_to_CFLOAT(timedelta *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (float)*ip++;
        *op++ = 0.0;
    }

}


#line 1398

#line 1407
static void
BOOL_to_CDOUBLE(Bool *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
BYTE_to_CDOUBLE(byte *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
UBYTE_to_CDOUBLE(ubyte *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
SHORT_to_CDOUBLE(short *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
USHORT_to_CDOUBLE(ushort *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
INT_to_CDOUBLE(int *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
UINT_to_CDOUBLE(uint *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONG_to_CDOUBLE(long *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
ULONG_to_CDOUBLE(ulong *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONGLONG_to_CDOUBLE(longlong *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
ULONGLONG_to_CDOUBLE(ulonglong *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
FLOAT_to_CDOUBLE(float *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
DOUBLE_to_CDOUBLE(double *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONGDOUBLE_to_CDOUBLE(longdouble *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
DATETIME_to_CDOUBLE(datetime *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
TIMEDELTA_to_CDOUBLE(timedelta *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (double)*ip++;
        *op++ = 0.0;
    }

}


#line 1398

#line 1407
static void
BOOL_to_CLONGDOUBLE(Bool *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
BYTE_to_CLONGDOUBLE(byte *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
UBYTE_to_CLONGDOUBLE(ubyte *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
SHORT_to_CLONGDOUBLE(short *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
USHORT_to_CLONGDOUBLE(ushort *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
INT_to_CLONGDOUBLE(int *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
UINT_to_CLONGDOUBLE(uint *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONG_to_CLONGDOUBLE(long *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
ULONG_to_CLONGDOUBLE(ulong *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONGLONG_to_CLONGDOUBLE(longlong *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
ULONGLONG_to_CLONGDOUBLE(ulonglong *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
FLOAT_to_CLONGDOUBLE(float *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
DOUBLE_to_CLONGDOUBLE(double *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
LONGDOUBLE_to_CLONGDOUBLE(longdouble *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
DATETIME_to_CLONGDOUBLE(datetime *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}

#line 1407
static void
TIMEDELTA_to_CLONGDOUBLE(timedelta *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (longdouble)*ip++;
        *op++ = 0.0;
    }

}



#line 1425

#line 1430
static void
CFLOAT_to_CFLOAT(float *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (float)*ip++;
    }
}


#line 1430
static void
CDOUBLE_to_CFLOAT(double *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (float)*ip++;
    }
}


#line 1430
static void
CLONGDOUBLE_to_CFLOAT(longdouble *ip, float *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (float)*ip++;
    }
}



#line 1425

#line 1430
static void
CFLOAT_to_CDOUBLE(float *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (double)*ip++;
    }
}


#line 1430
static void
CDOUBLE_to_CDOUBLE(double *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (double)*ip++;
    }
}


#line 1430
static void
CLONGDOUBLE_to_CDOUBLE(longdouble *ip, double *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (double)*ip++;
    }
}



#line 1425

#line 1430
static void
CFLOAT_to_CLONGDOUBLE(float *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}


#line 1430
static void
CDOUBLE_to_CLONGDOUBLE(double *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}


#line 1430
static void
CLONGDOUBLE_to_CLONGDOUBLE(longdouble *ip, longdouble *op, intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (longdouble)*ip++;
    }
}




#line 1455
static void
BOOL_to_OBJECT(Bool *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = BOOL_getitem((char *)ip, aip);
    }
}

#line 1455
static void
BYTE_to_OBJECT(byte *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = BYTE_getitem((char *)ip, aip);
    }
}

#line 1455
static void
UBYTE_to_OBJECT(ubyte *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = UBYTE_getitem((char *)ip, aip);
    }
}

#line 1455
static void
SHORT_to_OBJECT(short *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = SHORT_getitem((char *)ip, aip);
    }
}

#line 1455
static void
USHORT_to_OBJECT(ushort *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = USHORT_getitem((char *)ip, aip);
    }
}

#line 1455
static void
INT_to_OBJECT(int *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = INT_getitem((char *)ip, aip);
    }
}

#line 1455
static void
UINT_to_OBJECT(uint *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = UINT_getitem((char *)ip, aip);
    }
}

#line 1455
static void
LONG_to_OBJECT(long *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = LONG_getitem((char *)ip, aip);
    }
}

#line 1455
static void
ULONG_to_OBJECT(ulong *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = ULONG_getitem((char *)ip, aip);
    }
}

#line 1455
static void
LONGLONG_to_OBJECT(longlong *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = LONGLONG_getitem((char *)ip, aip);
    }
}

#line 1455
static void
ULONGLONG_to_OBJECT(ulonglong *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = ULONGLONG_getitem((char *)ip, aip);
    }
}

#line 1455
static void
HALF_to_OBJECT(npy_half *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = HALF_getitem((char *)ip, aip);
    }
}

#line 1455
static void
FLOAT_to_OBJECT(float *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = FLOAT_getitem((char *)ip, aip);
    }
}

#line 1455
static void
DOUBLE_to_OBJECT(double *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = DOUBLE_getitem((char *)ip, aip);
    }
}

#line 1455
static void
LONGDOUBLE_to_OBJECT(longdouble *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = LONGDOUBLE_getitem((char *)ip, aip);
    }
}

#line 1455
static void
CFLOAT_to_OBJECT(cfloat *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = CFLOAT_getitem((char *)ip, aip);
    }
}

#line 1455
static void
CDOUBLE_to_OBJECT(cdouble *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = CDOUBLE_getitem((char *)ip, aip);
    }
}

#line 1455
static void
CLONGDOUBLE_to_OBJECT(clongdouble *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = CLONGDOUBLE_getitem((char *)ip, aip);
    }
}

#line 1455
static void
STRING_to_OBJECT(char *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = aip->descr->elsize;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = STRING_getitem((char *)ip, aip);
    }
}

#line 1455
static void
UNICODE_to_OBJECT(char *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = aip->descr->elsize;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = UNICODE_getitem((char *)ip, aip);
    }
}

#line 1455
static void
VOID_to_OBJECT(char *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = aip->descr->elsize;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = VOID_getitem((char *)ip, aip);
    }
}

#line 1455
static void
OBJECT_to_OBJECT(PyObject * *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = OBJECT_getitem((char *)ip, aip);
    }
}

#line 1455
static void
DATETIME_to_OBJECT(datetime *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = DATETIME_getitem((char *)ip, aip);
    }
}

#line 1455
static void
TIMEDELTA_to_OBJECT(timedelta *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = 1;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = TIMEDELTA_getitem((char *)ip, aip);
    }
}


#define _NPY_UNUSEDBOOL  NPY_UNUSED
#define _NPY_UNUSEDBYTE  NPY_UNUSED
#define _NPY_UNUSEDUBYTE  NPY_UNUSED
#define _NPY_UNUSEDSHORT  NPY_UNUSED
#define _NPY_UNUSEDUSHORT  NPY_UNUSED
#define _NPY_UNUSEDINT  NPY_UNUSED
#define _NPY_UNUSEDUINT  NPY_UNUSED
#define _NPY_UNUSEDLONG  NPY_UNUSED
#define _NPY_UNUSEDULONG  NPY_UNUSED
#define _NPY_UNUSEDLONGLONG  NPY_UNUSED
#define _NPY_UNUSEDULONGLONG  NPY_UNUSED
#define _NPY_UNUSEDHALF NPY_UNUSED
#define _NPY_UNUSEDFLOAT  NPY_UNUSED
#define _NPY_UNUSEDDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDLONGDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDCFLOAT  NPY_UNUSED
#define _NPY_UNUSEDCDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDCLONGDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDDATETIME  NPY_UNUSED
#define _NPY_UNUSEDTIMEDELTA  NPY_UNUSED
#define _NPY_UNUSEDHALF NPY_UNUSED
#define _NPY_UNUSEDSTRING
#define _NPY_UNUSEDVOID
#define _NPY_UNUSEDUNICODE

#line 1505
static void
OBJECT_to_BOOL(PyObject **ip, Bool *op, intp n,
        PyArrayObject *_NPY_UNUSEDBOOL(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            BOOL_setitem(Py_False, (char *)op, aop);
        }
        else {
            BOOL_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_BYTE(PyObject **ip, byte *op, intp n,
        PyArrayObject *_NPY_UNUSEDBYTE(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            BYTE_setitem(Py_False, (char *)op, aop);
        }
        else {
            BYTE_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_UBYTE(PyObject **ip, ubyte *op, intp n,
        PyArrayObject *_NPY_UNUSEDUBYTE(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            UBYTE_setitem(Py_False, (char *)op, aop);
        }
        else {
            UBYTE_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_SHORT(PyObject **ip, short *op, intp n,
        PyArrayObject *_NPY_UNUSEDSHORT(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            SHORT_setitem(Py_False, (char *)op, aop);
        }
        else {
            SHORT_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_USHORT(PyObject **ip, ushort *op, intp n,
        PyArrayObject *_NPY_UNUSEDUSHORT(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            USHORT_setitem(Py_False, (char *)op, aop);
        }
        else {
            USHORT_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_INT(PyObject **ip, int *op, intp n,
        PyArrayObject *_NPY_UNUSEDINT(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            INT_setitem(Py_False, (char *)op, aop);
        }
        else {
            INT_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_UINT(PyObject **ip, uint *op, intp n,
        PyArrayObject *_NPY_UNUSEDUINT(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            UINT_setitem(Py_False, (char *)op, aop);
        }
        else {
            UINT_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_LONG(PyObject **ip, long *op, intp n,
        PyArrayObject *_NPY_UNUSEDLONG(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            LONG_setitem(Py_False, (char *)op, aop);
        }
        else {
            LONG_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_ULONG(PyObject **ip, ulong *op, intp n,
        PyArrayObject *_NPY_UNUSEDULONG(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            ULONG_setitem(Py_False, (char *)op, aop);
        }
        else {
            ULONG_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_LONGLONG(PyObject **ip, longlong *op, intp n,
        PyArrayObject *_NPY_UNUSEDLONGLONG(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            LONGLONG_setitem(Py_False, (char *)op, aop);
        }
        else {
            LONGLONG_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_ULONGLONG(PyObject **ip, ulonglong *op, intp n,
        PyArrayObject *_NPY_UNUSEDULONGLONG(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            ULONGLONG_setitem(Py_False, (char *)op, aop);
        }
        else {
            ULONGLONG_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_HALF(PyObject **ip, npy_half *op, intp n,
        PyArrayObject *_NPY_UNUSEDHALF(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            HALF_setitem(Py_False, (char *)op, aop);
        }
        else {
            HALF_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_FLOAT(PyObject **ip, float *op, intp n,
        PyArrayObject *_NPY_UNUSEDFLOAT(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            FLOAT_setitem(Py_False, (char *)op, aop);
        }
        else {
            FLOAT_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_DOUBLE(PyObject **ip, double *op, intp n,
        PyArrayObject *_NPY_UNUSEDDOUBLE(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            DOUBLE_setitem(Py_False, (char *)op, aop);
        }
        else {
            DOUBLE_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_LONGDOUBLE(PyObject **ip, longdouble *op, intp n,
        PyArrayObject *_NPY_UNUSEDLONGDOUBLE(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            LONGDOUBLE_setitem(Py_False, (char *)op, aop);
        }
        else {
            LONGDOUBLE_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_CFLOAT(PyObject **ip, cfloat *op, intp n,
        PyArrayObject *_NPY_UNUSEDCFLOAT(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            CFLOAT_setitem(Py_False, (char *)op, aop);
        }
        else {
            CFLOAT_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_CDOUBLE(PyObject **ip, cdouble *op, intp n,
        PyArrayObject *_NPY_UNUSEDCDOUBLE(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            CDOUBLE_setitem(Py_False, (char *)op, aop);
        }
        else {
            CDOUBLE_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_CLONGDOUBLE(PyObject **ip, clongdouble *op, intp n,
        PyArrayObject *_NPY_UNUSEDCLONGDOUBLE(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            CLONGDOUBLE_setitem(Py_False, (char *)op, aop);
        }
        else {
            CLONGDOUBLE_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_STRING(PyObject **ip, char *op, intp n,
        PyArrayObject *_NPY_UNUSEDSTRING(aip), PyArrayObject *aop)
{
    intp i;
    int skip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            STRING_setitem(Py_False, (char *)op, aop);
        }
        else {
            STRING_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_UNICODE(PyObject **ip, char *op, intp n,
        PyArrayObject *_NPY_UNUSEDUNICODE(aip), PyArrayObject *aop)
{
    intp i;
    int skip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            UNICODE_setitem(Py_False, (char *)op, aop);
        }
        else {
            UNICODE_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_VOID(PyObject **ip, char *op, intp n,
        PyArrayObject *_NPY_UNUSEDVOID(aip), PyArrayObject *aop)
{
    intp i;
    int skip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            VOID_setitem(Py_False, (char *)op, aop);
        }
        else {
            VOID_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_DATETIME(PyObject **ip, datetime *op, intp n,
        PyArrayObject *_NPY_UNUSEDDATETIME(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            DATETIME_setitem(Py_False, (char *)op, aop);
        }
        else {
            DATETIME_setitem(*ip, (char *)op, aop);
        }
    }
}

#line 1505
static void
OBJECT_to_TIMEDELTA(PyObject **ip, timedelta *op, intp n,
        PyArrayObject *_NPY_UNUSEDTIMEDELTA(aip), PyArrayObject *aop)
{
    intp i;
    int skip = 1;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            TIMEDELTA_setitem(Py_False, (char *)op, aop);
        }
        else {
            TIMEDELTA_setitem(*ip, (char *)op, aop);
        }
    }
}



#line 1534
static void
STRING_to_BOOL(char *ip, Bool *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (BOOL_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_BYTE(char *ip, byte *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (BYTE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_UBYTE(char *ip, ubyte *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (UBYTE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_SHORT(char *ip, short *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (SHORT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_USHORT(char *ip, ushort *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (USHORT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_INT(char *ip, int *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (INT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_UINT(char *ip, uint *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (UINT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_LONG(char *ip, long *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (LONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_ULONG(char *ip, ulong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (ULONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_LONGLONG(char *ip, longlong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (LONGLONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_ULONGLONG(char *ip, ulonglong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (ULONGLONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_HALF(char *ip, npy_half *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (HALF_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_FLOAT(char *ip, float *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (FLOAT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_DOUBLE(char *ip, double *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (DOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_LONGDOUBLE(char *ip, longdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (LONGDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_CFLOAT(char *ip, cfloat *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (CFLOAT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_CDOUBLE(char *ip, cdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (CDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_CLONGDOUBLE(char *ip, clongdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (CLONGDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_STRING(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_UNICODE(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_VOID(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_DATETIME(char *ip, datetime *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (DATETIME_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
STRING_to_TIMEDELTA(char *ip, timedelta *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = STRING_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (TIMEDELTA_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_BOOL(char *ip, Bool *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (BOOL_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_BYTE(char *ip, byte *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (BYTE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_UBYTE(char *ip, ubyte *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (UBYTE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_SHORT(char *ip, short *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (SHORT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_USHORT(char *ip, ushort *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (USHORT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_INT(char *ip, int *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (INT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_UINT(char *ip, uint *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (UINT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_LONG(char *ip, long *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (LONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_ULONG(char *ip, ulong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (ULONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_LONGLONG(char *ip, longlong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (LONGLONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_ULONGLONG(char *ip, ulonglong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (ULONGLONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_HALF(char *ip, npy_half *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (HALF_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_FLOAT(char *ip, float *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (FLOAT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_DOUBLE(char *ip, double *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (DOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_LONGDOUBLE(char *ip, longdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (LONGDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_CFLOAT(char *ip, cfloat *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (CFLOAT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_CDOUBLE(char *ip, cdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (CDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_CLONGDOUBLE(char *ip, clongdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (CLONGDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_STRING(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_UNICODE(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_VOID(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_DATETIME(char *ip, datetime *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (DATETIME_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
UNICODE_to_TIMEDELTA(char *ip, timedelta *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = UNICODE_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 1
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 1 */
        if (TIMEDELTA_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_BOOL(char *ip, Bool *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (BOOL_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_BYTE(char *ip, byte *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (BYTE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_UBYTE(char *ip, ubyte *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (UBYTE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_SHORT(char *ip, short *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (SHORT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_USHORT(char *ip, ushort *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (USHORT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_INT(char *ip, int *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (INT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_UINT(char *ip, uint *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (UINT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_LONG(char *ip, long *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (LONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_ULONG(char *ip, ulong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyInt_Type.tp_new(&PyInt_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (ULONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_LONGLONG(char *ip, longlong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (LONGLONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_ULONGLONG(char *ip, ulonglong *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (ULONGLONG_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_HALF(char *ip, npy_half *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (HALF_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_FLOAT(char *ip, float *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (FLOAT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_DOUBLE(char *ip, double *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (DOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_LONGDOUBLE(char *ip, longdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyFloat_Type.tp_new(&PyFloat_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (LONGDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_CFLOAT(char *ip, cfloat *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (CFLOAT_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_CDOUBLE(char *ip, cdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (CDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_CLONGDOUBLE(char *ip, clongdouble *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyComplex_Type.tp_new(&PyComplex_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (CLONGDOUBLE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_STRING(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_UNICODE(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_VOID(char *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = aop->descr->elsize;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyTuple_Type.tp_new(&PyTuple_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_DATETIME(char *ip, datetime *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (DATETIME_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#line 1534
static void
VOID_to_TIMEDELTA(char *ip, timedelta *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = aip->descr->elsize;
    int oskip = 1;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = VOID_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
#if 0
        {
        PyObject *new, *args;
        /* call out to the Python builtin given by convstr */
        args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
        new = PyLong_Type.tp_new(&PyLong_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
        Py_DECREF(args);
        temp = new;
        if (temp == NULL) {
            return;
        }
        }
#endif /* 0 */
        if (TIMEDELTA_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}



#line 1589
static void
BOOL_to_STRING(Bool *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = BOOL_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
BYTE_to_STRING(byte *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = BYTE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
UBYTE_to_STRING(ubyte *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = UBYTE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
SHORT_to_STRING(short *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = SHORT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
USHORT_to_STRING(ushort *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = USHORT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
INT_to_STRING(int *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = INT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
UINT_to_STRING(uint *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = UINT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONG_to_STRING(long *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
ULONG_to_STRING(ulong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = ULONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONGLONG_to_STRING(longlong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONGLONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
ULONGLONG_to_STRING(ulonglong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = ULONGLONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
HALF_to_STRING(npy_half *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = HALF_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
FLOAT_to_STRING(float *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = FLOAT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
DOUBLE_to_STRING(double *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = DOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONGDOUBLE_to_STRING(longdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONGDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CFLOAT_to_STRING(cfloat *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CFLOAT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CDOUBLE_to_STRING(cdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CLONGDOUBLE_to_STRING(clongdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CLONGDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
DATETIME_to_STRING(datetime *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = DATETIME_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
TIMEDELTA_to_STRING(timedelta *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = TIMEDELTA_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (STRING_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
BOOL_to_UNICODE(Bool *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = BOOL_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
BYTE_to_UNICODE(byte *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = BYTE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
UBYTE_to_UNICODE(ubyte *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = UBYTE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
SHORT_to_UNICODE(short *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = SHORT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
USHORT_to_UNICODE(ushort *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = USHORT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
INT_to_UNICODE(int *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = INT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
UINT_to_UNICODE(uint *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = UINT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONG_to_UNICODE(long *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
ULONG_to_UNICODE(ulong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = ULONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONGLONG_to_UNICODE(longlong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONGLONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
ULONGLONG_to_UNICODE(ulonglong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = ULONGLONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
HALF_to_UNICODE(npy_half *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = HALF_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
FLOAT_to_UNICODE(float *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = FLOAT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
DOUBLE_to_UNICODE(double *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = DOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONGDOUBLE_to_UNICODE(longdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONGDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CFLOAT_to_UNICODE(cfloat *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CFLOAT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CDOUBLE_to_UNICODE(cdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CLONGDOUBLE_to_UNICODE(clongdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CLONGDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
DATETIME_to_UNICODE(datetime *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = DATETIME_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
TIMEDELTA_to_UNICODE(timedelta *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = TIMEDELTA_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (UNICODE_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
BOOL_to_VOID(Bool *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = BOOL_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
BYTE_to_VOID(byte *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = BYTE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
UBYTE_to_VOID(ubyte *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = UBYTE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
SHORT_to_VOID(short *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = SHORT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
USHORT_to_VOID(ushort *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = USHORT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
INT_to_VOID(int *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = INT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
UINT_to_VOID(uint *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = UINT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONG_to_VOID(long *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
ULONG_to_VOID(ulong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = ULONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONGLONG_to_VOID(longlong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONGLONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
ULONGLONG_to_VOID(ulonglong *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = ULONGLONG_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
HALF_to_VOID(npy_half *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = HALF_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
FLOAT_to_VOID(float *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = FLOAT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
DOUBLE_to_VOID(double *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = DOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
LONGDOUBLE_to_VOID(longdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = LONGDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CFLOAT_to_VOID(cfloat *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CFLOAT_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CDOUBLE_to_VOID(cdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
CLONGDOUBLE_to_VOID(clongdouble *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = CLONGDOUBLE_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
DATETIME_to_VOID(datetime *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = DATETIME_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}


#line 1589
static void
TIMEDELTA_to_VOID(timedelta *ip, char *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = aop->descr->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = TIMEDELTA_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (VOID_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}




/*
 *****************************************************************************
 **                               SCAN                                      **
 *****************************************************************************
 */


/*
 * The first ignore argument is for backwards compatibility.
 * Should be removed when the API version is bumped up.
 */

#line 1631
static int
SHORT_scan(FILE *fp, short *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%""hd", ip);
}

#line 1631
static int
USHORT_scan(FILE *fp, ushort *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%""hu", ip);
}

#line 1631
static int
INT_scan(FILE *fp, int *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%""d", ip);
}

#line 1631
static int
UINT_scan(FILE *fp, uint *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%""u", ip);
}

#line 1631
static int
LONG_scan(FILE *fp, long *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%""ld", ip);
}

#line 1631
static int
ULONG_scan(FILE *fp, ulong *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%""lu", ip);
}

#line 1631
static int
LONGLONG_scan(FILE *fp, longlong *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%"LONGLONG_FMT, ip);
}

#line 1631
static int
ULONGLONG_scan(FILE *fp, ulonglong *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%"ULONGLONG_FMT, ip);
}


#line 1642
static int
FLOAT_scan(FILE *fp, float *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = (float) result;
    return ret;
}

#line 1642
static int
DOUBLE_scan(FILE *fp, double *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = (double) result;
    return ret;
}

#line 1642
static int
LONGDOUBLE_scan(FILE *fp, longdouble *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = (longdouble) result;
    return ret;
}


static int
HALF_scan(FILE *fp, npy_half *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = npy_double_to_half(result);
    return ret;
}

#line 1671
static int
BYTE_scan(FILE *fp, byte *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignore2))
{
    int temp;
    int num;

    num = fscanf(fp, "%""d", &temp);
    *ip = (byte) temp;
    return num;
}

#line 1671
static int
UBYTE_scan(FILE *fp, ubyte *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignore2))
{
    uint temp;
    int num;

    num = fscanf(fp, "%""u", &temp);
    *ip = (ubyte) temp;
    return num;
}


static int
BOOL_scan(FILE *fp, Bool *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignore2))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = (Bool) (result != 0.0);
    return ret;
}

#line 1698
#define CFLOAT_scan NULL

#line 1698
#define CDOUBLE_scan NULL

#line 1698
#define CLONGDOUBLE_scan NULL

#line 1698
#define OBJECT_scan NULL

#line 1698
#define STRING_scan NULL

#line 1698
#define UNICODE_scan NULL

#line 1698
#define VOID_scan NULL

#line 1698
#define DATETIME_scan NULL

#line 1698
#define TIMEDELTA_scan NULL



/*
 *****************************************************************************
 **                             FROMSTR                                     **
 *****************************************************************************
 */


#line 1717
static int
BYTE_fromstr(char *str, byte *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    long result;

    result = PyOS_strtol(str, endptr, 10);
    *ip = (byte) result;
    return 0;
}

#line 1717
static int
UBYTE_fromstr(char *str, ubyte *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    ulong result;

    result = PyOS_strtoul(str, endptr, 10);
    *ip = (ubyte) result;
    return 0;
}

#line 1717
static int
SHORT_fromstr(char *str, short *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    long result;

    result = PyOS_strtol(str, endptr, 10);
    *ip = (short) result;
    return 0;
}

#line 1717
static int
USHORT_fromstr(char *str, ushort *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    ulong result;

    result = PyOS_strtoul(str, endptr, 10);
    *ip = (ushort) result;
    return 0;
}

#line 1717
static int
INT_fromstr(char *str, int *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    long result;

    result = PyOS_strtol(str, endptr, 10);
    *ip = (int) result;
    return 0;
}

#line 1717
static int
UINT_fromstr(char *str, uint *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    ulong result;

    result = PyOS_strtoul(str, endptr, 10);
    *ip = (uint) result;
    return 0;
}

#line 1717
static int
LONG_fromstr(char *str, long *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    long result;

    result = PyOS_strtol(str, endptr, 10);
    *ip = (long) result;
    return 0;
}

#line 1717
static int
ULONG_fromstr(char *str, ulong *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    ulong result;

    result = PyOS_strtoul(str, endptr, 10);
    *ip = (ulong) result;
    return 0;
}

#line 1717
static int
LONGLONG_fromstr(char *str, longlong *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    long result;

    result = PyOS_strtol(str, endptr, 10);
    *ip = (longlong) result;
    return 0;
}

#line 1717
static int
ULONGLONG_fromstr(char *str, ulonglong *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    ulong result;

    result = PyOS_strtoul(str, endptr, 10);
    *ip = (ulonglong) result;
    return 0;
}

#line 1717
static int
DATETIME_fromstr(char *str, datetime *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    long result;

    result = PyOS_strtol(str, endptr, 10);
    *ip = (datetime) result;
    return 0;
}

#line 1717
static int
TIMEDELTA_fromstr(char *str, timedelta *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    long result;

    result = PyOS_strtol(str, endptr, 10);
    *ip = (timedelta) result;
    return 0;
}


#line 1733
static int
FLOAT_fromstr(char *str, float *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = (float) result;
    return 0;
}

#line 1733
static int
DOUBLE_fromstr(char *str, double *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = (double) result;
    return 0;
}

#line 1733
static int
LONGDOUBLE_fromstr(char *str, longdouble *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = (longdouble) result;
    return 0;
}


static int
HALF_fromstr(char *str, npy_half *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = npy_double_to_half(result);
    return 0;
}

static int
BOOL_fromstr(char *str, Bool *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = (Bool) (result != 0.0);
    return 0;
}

#line 1767
#define CFLOAT_fromstr NULL

#line 1767
#define CDOUBLE_fromstr NULL

#line 1767
#define CLONGDOUBLE_fromstr NULL

#line 1767
#define OBJECT_fromstr NULL

#line 1767
#define STRING_fromstr NULL

#line 1767
#define UNICODE_fromstr NULL

#line 1767
#define VOID_fromstr NULL



/*
 *****************************************************************************
 **                            COPYSWAPN                                    **
 *****************************************************************************
 */


#line 1787
static void
SHORT_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(short) && dstride == sizeof(short)) {
            memcpy(dst, src, n*sizeof(short));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(short));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(short));
    }
}

static void
SHORT_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(short));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_SHORT == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_SHORT == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_SHORT == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_SHORT == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_SHORT == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_SHORT == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_SHORT-1);
            nn = SIZEOF_SHORT / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
USHORT_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(ushort) && dstride == sizeof(ushort)) {
            memcpy(dst, src, n*sizeof(ushort));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(ushort));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(ushort));
    }
}

static void
USHORT_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(ushort));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_SHORT == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_SHORT == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_SHORT == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_SHORT == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_SHORT == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_SHORT == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_SHORT-1);
            nn = SIZEOF_SHORT / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
INT_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(int) && dstride == sizeof(int)) {
            memcpy(dst, src, n*sizeof(int));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(int));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(int));
    }
}

static void
INT_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(int));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_INT == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_INT == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_INT == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_INT == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_INT == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_INT == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_INT-1);
            nn = SIZEOF_INT / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
UINT_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(uint) && dstride == sizeof(uint)) {
            memcpy(dst, src, n*sizeof(uint));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(uint));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(uint));
    }
}

static void
UINT_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(uint));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_INT == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_INT == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_INT == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_INT == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_INT == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_INT == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_INT-1);
            nn = SIZEOF_INT / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
LONG_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(long) && dstride == sizeof(long)) {
            memcpy(dst, src, n*sizeof(long));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(long));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(long));
    }
}

static void
LONG_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(long));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_LONG == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_LONG == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONG == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONG == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONG == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONG == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_LONG-1);
            nn = SIZEOF_LONG / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
ULONG_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(ulong) && dstride == sizeof(ulong)) {
            memcpy(dst, src, n*sizeof(ulong));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(ulong));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(ulong));
    }
}

static void
ULONG_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(ulong));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_LONG == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_LONG == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONG == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONG == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONG == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONG == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_LONG-1);
            nn = SIZEOF_LONG / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
LONGLONG_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(longlong) && dstride == sizeof(longlong)) {
            memcpy(dst, src, n*sizeof(longlong));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(longlong));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(longlong));
    }
}

static void
LONGLONG_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(longlong));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_LONGLONG == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_LONGLONG == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGLONG == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGLONG == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGLONG == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGLONG == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_LONGLONG-1);
            nn = SIZEOF_LONGLONG / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
ULONGLONG_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(ulonglong) && dstride == sizeof(ulonglong)) {
            memcpy(dst, src, n*sizeof(ulonglong));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(ulonglong));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(ulonglong));
    }
}

static void
ULONGLONG_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(ulonglong));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_LONGLONG == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_LONGLONG == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGLONG == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGLONG == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGLONG == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGLONG == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_LONGLONG-1);
            nn = SIZEOF_LONGLONG / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
HALF_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(npy_half) && dstride == sizeof(npy_half)) {
            memcpy(dst, src, n*sizeof(npy_half));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(npy_half));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(npy_half));
    }
}

static void
HALF_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(npy_half));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_HALF == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_HALF == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_HALF == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_HALF == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_HALF == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_HALF == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_HALF-1);
            nn = SIZEOF_HALF / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
FLOAT_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(float) && dstride == sizeof(float)) {
            memcpy(dst, src, n*sizeof(float));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(float));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(float));
    }
}

static void
FLOAT_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(float));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_FLOAT == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_FLOAT == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_FLOAT == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_FLOAT == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_FLOAT == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_FLOAT == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_FLOAT-1);
            nn = SIZEOF_FLOAT / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
DOUBLE_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(double) && dstride == sizeof(double)) {
            memcpy(dst, src, n*sizeof(double));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(double));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(double));
    }
}

static void
DOUBLE_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(double));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_DOUBLE == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_DOUBLE == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DOUBLE == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DOUBLE == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DOUBLE == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DOUBLE == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_DOUBLE-1);
            nn = SIZEOF_DOUBLE / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
LONGDOUBLE_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(longdouble) && dstride == sizeof(longdouble)) {
            memcpy(dst, src, n*sizeof(longdouble));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(longdouble));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(longdouble));
    }
}

static void
LONGDOUBLE_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(longdouble));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_LONGDOUBLE == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_LONGDOUBLE == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGDOUBLE == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGDOUBLE == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGDOUBLE == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGDOUBLE == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_LONGDOUBLE-1);
            nn = SIZEOF_LONGDOUBLE / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
DATETIME_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(datetime) && dstride == sizeof(datetime)) {
            memcpy(dst, src, n*sizeof(datetime));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(datetime));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(datetime));
    }
}

static void
DATETIME_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(datetime));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_DATETIME == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_DATETIME == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DATETIME == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DATETIME == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DATETIME == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DATETIME == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_DATETIME-1);
            nn = SIZEOF_DATETIME / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1787
static void
TIMEDELTA_copyswapn (void *dst, intp dstride, void *src, intp sstride,
                   intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(timedelta) && dstride == sizeof(timedelta)) {
            memcpy(dst, src, n*sizeof(timedelta));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(timedelta));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(timedelta));
    }
}

static void
TIMEDELTA_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(timedelta));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if SIZEOF_TIMEDELTA == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif SIZEOF_TIMEDELTA == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_TIMEDELTA == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_TIMEDELTA == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_TIMEDELTA == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_TIMEDELTA == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_TIMEDELTA-1);
            nn = SIZEOF_TIMEDELTA / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}



#line 1878
static void
BOOL_copyswapn (void *dst, intp dstride, void *src, intp sstride, intp n,
                   int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(Bool) && dstride == sizeof(Bool)) {
            memcpy(dst, src, n*sizeof(Bool));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(Bool));
        }
    }
    /* ignore swap */
}

static void
BOOL_copyswap (void *dst, void *src, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(Bool));
    }
    /* ignore swap */
}


#line 1878
static void
BYTE_copyswapn (void *dst, intp dstride, void *src, intp sstride, intp n,
                   int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(byte) && dstride == sizeof(byte)) {
            memcpy(dst, src, n*sizeof(byte));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(byte));
        }
    }
    /* ignore swap */
}

static void
BYTE_copyswap (void *dst, void *src, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(byte));
    }
    /* ignore swap */
}


#line 1878
static void
UBYTE_copyswapn (void *dst, intp dstride, void *src, intp sstride, intp n,
                   int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(ubyte) && dstride == sizeof(ubyte)) {
            memcpy(dst, src, n*sizeof(ubyte));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(ubyte));
        }
    }
    /* ignore swap */
}

static void
UBYTE_copyswap (void *dst, void *src, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(ubyte));
    }
    /* ignore swap */
}





#line 1914
static void
CFLOAT_copyswapn (void *dst, intp dstride, void *src, intp sstride, intp n,
                   int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        if (sstride == sizeof(cfloat) && dstride == sizeof(cfloat)) {
            memcpy(dst, src, n*sizeof(cfloat));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride, n,
                    sizeof(cfloat));
        }
    }

    if (swap) {
        _strided_byte_swap(dst, dstride, n, SIZEOF_FLOAT);
        _strided_byte_swap(((char *)dst + SIZEOF_FLOAT), dstride,
                n, SIZEOF_FLOAT);
    }
}

static void
CFLOAT_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) /* copy first if needed */
        memcpy(dst, src, sizeof(cfloat));

    if (swap) {
        char *a, *b, c;
        a = (char *)dst;
#if SIZEOF_FLOAT == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 2;
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_FLOAT == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 4;
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_FLOAT == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 5;
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_FLOAT == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 6;
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_FLOAT == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 8;
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_FLOAT - 1);
            nn = SIZEOF_FLOAT / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
            a += nn / 2;
            b = a + (SIZEOF_FLOAT - 1);
            nn = SIZEOF_FLOAT / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1914
static void
CDOUBLE_copyswapn (void *dst, intp dstride, void *src, intp sstride, intp n,
                   int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        if (sstride == sizeof(cdouble) && dstride == sizeof(cdouble)) {
            memcpy(dst, src, n*sizeof(cdouble));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride, n,
                    sizeof(cdouble));
        }
    }

    if (swap) {
        _strided_byte_swap(dst, dstride, n, SIZEOF_DOUBLE);
        _strided_byte_swap(((char *)dst + SIZEOF_DOUBLE), dstride,
                n, SIZEOF_DOUBLE);
    }
}

static void
CDOUBLE_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) /* copy first if needed */
        memcpy(dst, src, sizeof(cdouble));

    if (swap) {
        char *a, *b, c;
        a = (char *)dst;
#if SIZEOF_DOUBLE == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 2;
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DOUBLE == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 4;
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DOUBLE == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 5;
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DOUBLE == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 6;
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_DOUBLE == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 8;
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_DOUBLE - 1);
            nn = SIZEOF_DOUBLE / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
            a += nn / 2;
            b = a + (SIZEOF_DOUBLE - 1);
            nn = SIZEOF_DOUBLE / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}


#line 1914
static void
CLONGDOUBLE_copyswapn (void *dst, intp dstride, void *src, intp sstride, intp n,
                   int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        if (sstride == sizeof(clongdouble) && dstride == sizeof(clongdouble)) {
            memcpy(dst, src, n*sizeof(clongdouble));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride, n,
                    sizeof(clongdouble));
        }
    }

    if (swap) {
        _strided_byte_swap(dst, dstride, n, SIZEOF_LONGDOUBLE);
        _strided_byte_swap(((char *)dst + SIZEOF_LONGDOUBLE), dstride,
                n, SIZEOF_LONGDOUBLE);
    }
}

static void
CLONGDOUBLE_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) /* copy first if needed */
        memcpy(dst, src, sizeof(clongdouble));

    if (swap) {
        char *a, *b, c;
        a = (char *)dst;
#if SIZEOF_LONGDOUBLE == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 2;
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGDOUBLE == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 4;
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGDOUBLE == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 5;
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGDOUBLE == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 6;
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif SIZEOF_LONGDOUBLE == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 8;
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (SIZEOF_LONGDOUBLE - 1);
            nn = SIZEOF_LONGDOUBLE / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
            a += nn / 2;
            b = a + (SIZEOF_LONGDOUBLE - 1);
            nn = SIZEOF_LONGDOUBLE / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}



static void
OBJECT_copyswapn (PyObject **dst, intp dstride, PyObject **src, intp sstride,
                  intp n, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    intp i;
    if (src != NULL) {
        if (__ALIGNED(dst, sizeof(PyObject **))
                && __ALIGNED(src, sizeof(PyObject **))
                && __ALIGNED(dstride, sizeof(PyObject **))
                && __ALIGNED(sstride, sizeof(PyObject **))) {
            dstride /= sizeof(PyObject **);
            sstride /= sizeof(PyObject **);
            for (i = 0; i < n; i++) {
                Py_XINCREF(*src);
                Py_XDECREF(*dst);
                *dst = *src;
                dst += dstride;
                src += sstride;
            }
        }
        else {
            unsigned char *dstp, *srcp;
            PyObject *tmp;
            dstp = (unsigned char*)dst;
            srcp = (unsigned char*)src;
            for (i = 0; i < n; i++) {
                NPY_COPY_PYOBJECT_PTR(&tmp, dstp);
                Py_XDECREF(tmp);
                NPY_COPY_PYOBJECT_PTR(&tmp, srcp);
                Py_XINCREF(tmp);
                NPY_COPY_PYOBJECT_PTR(dstp, srcp);
                dstp += dstride;
                srcp += sstride;
            }
        }
    }
    /* ignore swap */
    return;
}

static void
OBJECT_copyswap(PyObject **dst, PyObject **src, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        if (__ALIGNED(dst,sizeof(PyObject **)) && __ALIGNED(src,sizeof(PyObject **))) {
            Py_XINCREF(*src);
            Py_XDECREF(*dst);
            *dst = *src;
        }
        else {
            PyObject *tmp;
            NPY_COPY_PYOBJECT_PTR(&tmp, dst);
            Py_XDECREF(tmp);
            NPY_COPY_PYOBJECT_PTR(&tmp, src);
            Py_XINCREF(tmp);
            NPY_COPY_PYOBJECT_PTR(dst, src);
        }
    }
}

/* ignore swap */
static void
STRING_copyswapn (char *dst, intp dstride, char *src, intp sstride,
                  intp n, int NPY_UNUSED(swap), PyArrayObject *arr)
{
    if (src != NULL && arr != NULL) {
        int itemsize = arr->descr->elsize;

        if (dstride == itemsize && sstride == itemsize) {
            memcpy(dst, src, itemsize * n);
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride, n,
                    itemsize);
        }
    }
    return;
}

/* */
static void
VOID_copyswapn (char *dst, intp dstride, char *src, intp sstride,
                intp n, int swap, PyArrayObject *arr)
{
    if (arr == NULL) {
        return;
    }
    if (PyArray_HASFIELDS(arr)) {
        PyObject *key, *value, *title = NULL;
        PyArray_Descr *new, *descr;
        int offset;
        Py_ssize_t pos = 0;

        descr = arr->descr;
        while (PyDict_Next(descr->fields, &pos, &key, &value)) {
            if NPY_TITLE_KEY(key, value) {
                continue;
            }
            if (!PyArg_ParseTuple(value, "Oi|O", &new, &offset, &title)) {
                arr->descr = descr;
                return;
            }
            arr->descr = new;
            new->f->copyswapn(dst+offset, dstride,
                    (src != NULL ? src+offset : NULL),
                    sstride, n, swap, arr);
        }
        arr->descr = descr;
        return;
    }
    if (swap && arr->descr->subarray != NULL) {
        PyArray_Descr *descr, *new;
        npy_intp num;
        npy_intp i;
        int subitemsize;
        char *dstptr, *srcptr;

        descr = arr->descr;
        new = descr->subarray->base;
        arr->descr = new;
        dstptr = dst;
        srcptr = src;
        subitemsize = new->elsize;
        num = descr->elsize / subitemsize;
        for (i = 0; i < n; i++) {
            new->f->copyswapn(dstptr, subitemsize, srcptr,
                    subitemsize, num, swap, arr);
            dstptr += dstride;
            if (srcptr) {
                srcptr += sstride;
            }
        }
        arr->descr = descr;
        return;
    }
    if (src != NULL) {
        memcpy(dst, src, arr->descr->elsize * n);
    }
    return;
}

static void
VOID_copyswap (char *dst, char *src, int swap, PyArrayObject *arr)
{
    if (arr == NULL) {
        return;
    }
    if (PyArray_HASFIELDS(arr)) {
        PyObject *key, *value, *title = NULL;
        PyArray_Descr *new, *descr;
        int offset;
        Py_ssize_t pos = 0;

        descr = arr->descr;
        while (PyDict_Next(descr->fields, &pos, &key, &value)) {
            if NPY_TITLE_KEY(key, value) {
                continue;
            }
            if (!PyArg_ParseTuple(value, "Oi|O", &new, &offset, &title)) {
                arr->descr = descr;
                return;
            }
            arr->descr = new;
            new->f->copyswap(dst+offset,
                    (src != NULL ? src+offset : NULL),
                    swap, arr);
        }
        arr->descr = descr;
        return;
    }
    if (swap && arr->descr->subarray != NULL) {
        PyArray_Descr *descr, *new;
        npy_intp num;
        int itemsize;

        descr = arr->descr;
        new = descr->subarray->base;
        arr->descr = new;
        itemsize = new->elsize;
        num = descr->elsize / itemsize;
        new->f->copyswapn(dst, itemsize, src,
                itemsize, num, swap, arr);
        arr->descr = descr;
        return;
    }
    if (src != NULL) {
        memcpy(dst, src, arr->descr->elsize);
    }
    return;
}


static void
UNICODE_copyswapn (char *dst, intp dstride, char *src, intp sstride,
                   intp n, int swap, PyArrayObject *arr)
{
    int itemsize;

    if (arr == NULL) {
        return;
    }
    itemsize = arr->descr->elsize;
    if (src != NULL) {
        if (dstride == itemsize && sstride == itemsize) {
            memcpy(dst, src, n * itemsize);
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src,
                    sstride, n, itemsize);
        }
    }

    n *= itemsize;
    if (swap) {
        char *a, *b, c;

        /* n is the number of unicode characters to swap */
        n >>= 2;
        for (a = (char *)dst; n > 0; n--) {
            b = a + 3;
            c = *a;
            *a++ = *b;
            *b-- = c;
            c = *a;
            *a++ = *b;
            *b-- = c;
            a += 2;
        }
    }
}


static void
STRING_copyswap(char *dst, char *src, int NPY_UNUSED(swap), PyArrayObject *arr)
{
    if (src != NULL && arr != NULL) {
        memcpy(dst, src, arr->descr->elsize);
    }
}

static void
UNICODE_copyswap (char *dst, char *src, int swap, PyArrayObject *arr)
{
    int itemsize;

    if (arr == NULL) {
        return;
    }
    itemsize = arr->descr->elsize;
    if (src != NULL) {
        memcpy(dst, src, itemsize);
    }

    if (swap) {
        char *a, *b, c;
        itemsize >>= 2;
        for (a = (char *)dst; itemsize>0; itemsize--) {
            b = a + 3;
            c = *a;
            *a++ = *b;
            *b-- = c;
            c = *a;
            *a++ = *b;
            *b-- = c;
            a += 2;
        }
    }
}


/*
 *****************************************************************************
 **                                 NONZERO                                 **
 *****************************************************************************
 */

#define _NONZERO(a) ((a) != 0)

#line 2332
static Bool
BOOL_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        Bool *ptmp = (Bool *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        Bool tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(Bool));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
BYTE_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        byte *ptmp = (byte *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        byte tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(byte));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
UBYTE_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        ubyte *ptmp = (ubyte *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        ubyte tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(ubyte));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
SHORT_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        short *ptmp = (short *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        short tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(short));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
USHORT_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        ushort *ptmp = (ushort *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        ushort tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(ushort));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
INT_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        int *ptmp = (int *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        int tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(int));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
UINT_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        uint *ptmp = (uint *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        uint tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(uint));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
LONG_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        long *ptmp = (long *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        long tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(long));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
ULONG_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        ulong *ptmp = (ulong *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        ulong tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(ulong));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
LONGLONG_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        longlong *ptmp = (longlong *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        longlong tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(longlong));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
ULONGLONG_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        ulonglong *ptmp = (ulonglong *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        ulonglong tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(ulonglong));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
HALF_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        npy_half *ptmp = (npy_half *)ip;
        return (Bool) !npy_half_iszero(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        npy_half tmp;
#if 1
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(npy_half));
#endif
        return (Bool) !npy_half_iszero(tmp);
    }
}

#line 2332
static Bool
FLOAT_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        float *ptmp = (float *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        float tmp;
#if 1
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(float));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
DOUBLE_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        double *ptmp = (double *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        double tmp;
#if 1
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(double));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
LONGDOUBLE_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        longdouble *ptmp = (longdouble *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        longdouble tmp;
#if 1
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(longdouble));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
DATETIME_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        datetime *ptmp = (datetime *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        datetime tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(datetime));
#endif
        return (Bool) _NONZERO(tmp);
    }
}

#line 2332
static Bool
TIMEDELTA_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        timedelta *ptmp = (timedelta *)ip;
        return (Bool) _NONZERO(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        timedelta tmp;
#if 0
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(timedelta));
#endif
        return (Bool) _NONZERO(tmp);
    }
}


#line 2361
static Bool
CFLOAT_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        cfloat *ptmp = (cfloat *)ip;
        return (Bool) ((ptmp->real != 0) || (ptmp->imag != 0));
    }
    else {
        cfloat tmp;
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return (Bool) ((tmp.real != 0) || (tmp.imag != 0));
    }
}

#line 2361
static Bool
CDOUBLE_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        cdouble *ptmp = (cdouble *)ip;
        return (Bool) ((ptmp->real != 0) || (ptmp->imag != 0));
    }
    else {
        cdouble tmp;
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return (Bool) ((tmp.real != 0) || (tmp.imag != 0));
    }
}

#line 2361
static Bool
CLONGDOUBLE_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        clongdouble *ptmp = (clongdouble *)ip;
        return (Bool) ((ptmp->real != 0) || (ptmp->imag != 0));
    }
    else {
        clongdouble tmp;
        ap->descr->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return (Bool) ((tmp.real != 0) || (tmp.imag != 0));
    }
}



#define WHITESPACE " \t\n\r\v\f"
#define WHITELEN 6

static Bool
Py_STRING_ISSPACE(char ch)
{
    char white[] = WHITESPACE;
    int j;
    Bool space = FALSE;

    for (j = 0; j < WHITELEN; j++) {
        if (ch == white[j]) {
            space = TRUE;
            break;
        }
    }
    return space;
}

static Bool
STRING_nonzero (char *ip, PyArrayObject *ap)
{
    int len = ap->descr->elsize;
    int i;
    Bool nonz = FALSE;

    for (i = 0; i < len; i++) {
        if (!Py_STRING_ISSPACE(*ip)) {
            nonz = TRUE;
            break;
        }
        ip++;
    }
    return nonz;
}

#ifdef Py_UNICODE_WIDE
#define PyArray_UCS4_ISSPACE Py_UNICODE_ISSPACE
#else
#define PyArray_UCS4_ISSPACE(ch) Py_STRING_ISSPACE((char)ch)
#endif

static Bool
UNICODE_nonzero (PyArray_UCS4 *ip, PyArrayObject *ap)
{
    int len = ap->descr->elsize >> 2;
    int i;
    Bool nonz = FALSE;
    char *buffer = NULL;

    if ((!PyArray_ISNOTSWAPPED(ap)) || (!PyArray_ISALIGNED(ap))) {
        buffer = _pya_malloc(ap->descr->elsize);
        if (buffer == NULL) {
            return nonz;
        }
        memcpy(buffer, ip, ap->descr->elsize);
        if (!PyArray_ISNOTSWAPPED(ap)) {
            byte_swap_vector(buffer, len, 4);
        }
        ip = (PyArray_UCS4 *)buffer;
    }

    for (i = 0; i < len; i++) {
        if (!PyArray_UCS4_ISSPACE(*ip)) {
            nonz = TRUE;
            break;
        }
        ip++;
    }
    _pya_free(buffer);
    return nonz;
}

static Bool
OBJECT_nonzero (PyObject **ip, PyArrayObject *ap)
{

    if (PyArray_ISALIGNED(ap)) {
        if (*ip == NULL) {
            return FALSE;
        }
        return (Bool) PyObject_IsTrue(*ip);
    }
    else {
        PyObject *obj;
        NPY_COPY_PYOBJECT_PTR(&obj, ip);
        if (obj == NULL) {
            return FALSE;
        }
        return (Bool) PyObject_IsTrue(obj);
    }
}

/*
 * if we have fields, then nonzero only if all sub-fields are nonzero.
 */
static Bool
VOID_nonzero (char *ip, PyArrayObject *ap)
{
    int i;
    int len;
    Bool nonz = FALSE;

    if (PyArray_HASFIELDS(ap)) {
        PyArray_Descr *descr, *new;
        PyObject *key, *value, *title;
        int savedflags, offset;
        Py_ssize_t pos = 0;

        descr = ap->descr;
        savedflags = ap->flags;
        while (PyDict_Next(descr->fields, &pos, &key, &value)) {
            if NPY_TITLE_KEY(key, value) {
                continue;
            }
            if (!PyArg_ParseTuple(value, "Oi|O", &new, &offset,
                        &title)) {
                PyErr_Clear();
                continue;
            }
            ap->descr = new;
            ap->flags = savedflags;
            if ((new->alignment > 1) && !__ALIGNED(ip+offset, new->alignment)) {
                ap->flags &= ~ALIGNED;
            }
            else {
                ap->flags |= ALIGNED;
            }
            if (new->f->nonzero(ip+offset, ap)) {
                nonz = TRUE;
                break;
            }
        }
        ap->descr = descr;
        ap->flags = savedflags;
        return nonz;
    }
    len = ap->descr->elsize;
    for (i = 0; i < len; i++) {
        if (*ip != '\0') {
            nonz = TRUE;
            break;
        }
        ip++;
    }
    return nonz;
}

#undef __ALIGNED


/*
 *****************************************************************************
 **                                 COMPARE                                 **
 *****************************************************************************
 */


/* boolean type */

static int
BOOL_compare(Bool *ip1, Bool *ip2, PyArrayObject *NPY_UNUSED(ap))
{
    return (*ip1 ? (*ip2 ? 0 : 1) : (*ip2 ? -1 : 0));
}


/* integer types */

#line 2552

static int
BYTE_compare (byte *pa, byte *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const byte a = *pa;
    const byte b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
UBYTE_compare (ubyte *pa, ubyte *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const ubyte a = *pa;
    const ubyte b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
SHORT_compare (short *pa, short *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const short a = *pa;
    const short b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
USHORT_compare (ushort *pa, ushort *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const ushort a = *pa;
    const ushort b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
INT_compare (int *pa, int *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const int a = *pa;
    const int b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
UINT_compare (uint *pa, uint *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const uint a = *pa;
    const uint b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
LONG_compare (long *pa, long *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const long a = *pa;
    const long b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
ULONG_compare (ulong *pa, ulong *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const ulong a = *pa;
    const ulong b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
LONGLONG_compare (longlong *pa, longlong *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const longlong a = *pa;
    const longlong b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
ULONGLONG_compare (ulonglong *pa, ulonglong *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const ulonglong a = *pa;
    const ulonglong b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
DATETIME_compare (datetime *pa, datetime *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const datetime a = *pa;
    const datetime b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}


#line 2552

static int
TIMEDELTA_compare (timedelta *pa, timedelta *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const timedelta a = *pa;
    const timedelta b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}




/* float types */

/*
 * The real/complex comparison functions are compatible with the new sort
 * order for nans introduced in numpy 1.4.0. All nan values now compare
 * larger than non-nan values and are sorted to the end. The comparison
 * order is:
 *
 *      Real: [R, nan]
 *      Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
 *
 *  where complex values with the same nan placements are sorted according
 *  to the non-nan part if it exists. If both the real and imaginary parts
 *  of complex types are non-nan the order is the same as the real parts
 *  unless they happen to be equal, in which case the order is that of the
 *  imaginary parts.
 */

#line 2588

#define LT(a,b) ((a) < (b) || ((b) != (b) && (a) ==(a)))

static int
FLOAT_compare(float *pa, float *pb)
{
    const float a = *pa;
    const float b = *pb;
    int ret;

    if (LT(a,b)) {
        ret = -1;
    }
    else if (LT(b,a)) {
        ret = 1;
    }
    else {
        ret = 0;
    }
    return ret;
}


static int
CFLOAT_compare(float *pa, float *pb)
{
    const float ar = pa[0];
    const float ai = pa[1];
    const float br = pb[0];
    const float bi = pb[1];
    int ret;

    if (ar < br) {
        if (ai == ai || bi != bi) {
            ret = -1;
        }
        else {
            ret = 1;
        }
    }
    else if (br < ar) {
        if (bi == bi || ai != ai) {
            ret = 1;
        }
        else {
            ret = -1;
        }
    }
    else if (ar == br || (ar != ar && br != br)) {
        if (LT(ai,bi)) {
            ret = -1;
        }
        else if (LT(bi,ai)) {
            ret = 1;
        }
        else {
            ret = 0;
        }
    }
    else if (ar == ar) {
        ret = -1;
    }
    else {
        ret = 1;
    }

    return ret;
}

#undef LT


#line 2588

#define LT(a,b) ((a) < (b) || ((b) != (b) && (a) ==(a)))

static int
DOUBLE_compare(double *pa, double *pb)
{
    const double a = *pa;
    const double b = *pb;
    int ret;

    if (LT(a,b)) {
        ret = -1;
    }
    else if (LT(b,a)) {
        ret = 1;
    }
    else {
        ret = 0;
    }
    return ret;
}


static int
CDOUBLE_compare(double *pa, double *pb)
{
    const double ar = pa[0];
    const double ai = pa[1];
    const double br = pb[0];
    const double bi = pb[1];
    int ret;

    if (ar < br) {
        if (ai == ai || bi != bi) {
            ret = -1;
        }
        else {
            ret = 1;
        }
    }
    else if (br < ar) {
        if (bi == bi || ai != ai) {
            ret = 1;
        }
        else {
            ret = -1;
        }
    }
    else if (ar == br || (ar != ar && br != br)) {
        if (LT(ai,bi)) {
            ret = -1;
        }
        else if (LT(bi,ai)) {
            ret = 1;
        }
        else {
            ret = 0;
        }
    }
    else if (ar == ar) {
        ret = -1;
    }
    else {
        ret = 1;
    }

    return ret;
}

#undef LT


#line 2588

#define LT(a,b) ((a) < (b) || ((b) != (b) && (a) ==(a)))

static int
LONGDOUBLE_compare(longdouble *pa, longdouble *pb)
{
    const longdouble a = *pa;
    const longdouble b = *pb;
    int ret;

    if (LT(a,b)) {
        ret = -1;
    }
    else if (LT(b,a)) {
        ret = 1;
    }
    else {
        ret = 0;
    }
    return ret;
}


static int
CLONGDOUBLE_compare(longdouble *pa, longdouble *pb)
{
    const longdouble ar = pa[0];
    const longdouble ai = pa[1];
    const longdouble br = pb[0];
    const longdouble bi = pb[1];
    int ret;

    if (ar < br) {
        if (ai == ai || bi != bi) {
            ret = -1;
        }
        else {
            ret = 1;
        }
    }
    else if (br < ar) {
        if (bi == bi || ai != ai) {
            ret = 1;
        }
        else {
            ret = -1;
        }
    }
    else if (ar == br || (ar != ar && br != br)) {
        if (LT(ai,bi)) {
            ret = -1;
        }
        else if (LT(bi,ai)) {
            ret = 1;
        }
        else {
            ret = 0;
        }
    }
    else if (ar == ar) {
        ret = -1;
    }
    else {
        ret = 1;
    }

    return ret;
}

#undef LT



static int
HALF_compare (npy_half *pa, npy_half *pb, PyArrayObject *NPY_UNUSED(ap))
{
    npy_half a = *pa, b = *pb;
    Bool a_isnan, b_isnan;
    int ret;

    a_isnan = npy_half_isnan(a);
    b_isnan = npy_half_isnan(b);

    if (a_isnan) {
        ret = b_isnan ? 0 : -1;
    } else if (b_isnan) {
        ret = 1;
    } else if(npy_half_lt_nonan(a, b)) {
        ret = -1;
    } else if(npy_half_lt_nonan(b, a)) {
        ret = 1;
    } else {
        ret = 0;
    }

    return ret;
}


/* object type */

static int
OBJECT_compare(PyObject **ip1, PyObject **ip2, PyArrayObject *NPY_UNUSED(ap))
{
    /*
     * ALIGNMENT NOTE: It seems that PyArray_Sort is already handling
     * the alignment of pointers, so it doesn't need to be handled
     * here.
     */
    if ((*ip1 == NULL) || (*ip2 == NULL)) {
        if (ip1 == ip2) {
            return 1;
        }
        if (ip1 == NULL) {
            return -1;
        }
        return 1;
    }
#if defined(NPY_PY3K)
    if (PyObject_RichCompareBool(*ip1, *ip2, Py_LT) == 1) {
        return -1;
    }
    else if (PyObject_RichCompareBool(*ip1, *ip2, Py_GT) == 1) {
        return 1;
    }
    else {
        return 0;
    }
#else
    return PyObject_Compare(*ip1, *ip2);
#endif
}


/* string type */

static int
STRING_compare(char *ip1, char *ip2, PyArrayObject *ap)
{
    const unsigned char *c1 = (unsigned char *)ip1;
    const unsigned char *c2 = (unsigned char *)ip2;
    const size_t len = ap->descr->elsize;
    size_t i;

    for(i = 0; i < len; ++i) {
        if (c1[i] != c2[i]) {
            return (c1[i] > c2[i]) ? 1 : -1;
        }
    }
    return 0;
}


/* unicode type */

static int
UNICODE_compare(PyArray_UCS4 *ip1, PyArray_UCS4 *ip2,
                PyArrayObject *ap)
{
    int itemsize = ap->descr->elsize;

    if (itemsize < 0) {
        return 0;
    }
    itemsize >>= 2;
    while (itemsize-- > 0) {
        PyArray_UCS4 c1 = *ip1++;
        PyArray_UCS4 c2 = *ip2++;
        if (c1 != c2) {
            return (c1 < c2) ? -1 : 1;
        }
    }
    return 0;
}


/* void type */

/*
 * If fields are defined, then compare on first field and if equal
 * compare on second field.  Continue until done or comparison results
 * in not_equal.
 *
 * Must align data passed on to sub-comparisons.
 * Also must swap data based on to sub-comparisons.
 */
static int
VOID_compare(char *ip1, char *ip2, PyArrayObject *ap)
{
    PyArray_Descr *descr, *new;
    PyObject *names, *key;
    PyObject *tup, *title;
    char *nip1, *nip2;
    int i, offset, res = 0, swap=0;

    if (!PyArray_HASFIELDS(ap)) {
        return STRING_compare(ip1, ip2, ap);
    }
    descr = ap->descr;
    /*
     * Compare on the first-field.  If equal, then
     * compare on the second-field, etc.
     */
    names = descr->names;
    for (i = 0; i < PyTuple_GET_SIZE(names); i++) {
        key = PyTuple_GET_ITEM(names, i);
        tup = PyDict_GetItem(descr->fields, key);
        if (!PyArg_ParseTuple(tup, "Oi|O", &new, &offset, &title)) {
            goto finish;
        }
        ap->descr = new;
        swap = PyArray_ISBYTESWAPPED(ap);
        nip1 = ip1+offset;
        nip2 = ip2+offset;
        if ((swap) || (new->alignment > 1)) {
            if ((swap) || (((intp)(nip1) % new->alignment) != 0)) {
                /* create buffer and copy */
                nip1 = _pya_malloc(new->elsize);
                if (nip1 == NULL) {
                    goto finish;
                }
                memcpy(nip1, ip1+offset, new->elsize);
                if (swap)
                    new->f->copyswap(nip1, NULL, swap, ap);
            }
            if ((swap) || (((intp)(nip2) % new->alignment) != 0)) {
                /* copy data to a buffer */
                nip2 = _pya_malloc(new->elsize);
                if (nip2 == NULL) {
                    if (nip1 != ip1+offset) {
                        _pya_free(nip1);
                    }
                    goto finish;
                }
                memcpy(nip2, ip2+offset, new->elsize);
                if (swap)
                    new->f->copyswap(nip2, NULL, swap, ap);
            }
        }
        res = new->f->compare(nip1, nip2, ap);
        if ((swap) || (new->alignment > 1)) {
            if (nip1 != ip1+offset) {
                _pya_free(nip1);
            }
            if (nip2 != ip2+offset) {
                _pya_free(nip2);
            }
        }
        if (res != 0) {
            break;
        }
    }

finish:
    ap->descr = descr;
    return res;
}


/*
 *****************************************************************************
 **                                 ARGFUNC                                 **
 *****************************************************************************
 */

#define _LESS_THAN_OR_EQUAL(a,b) ((a) <= (b))

#line 2869
static int
BOOL_argmax(Bool *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    Bool mp = *ip;
#if 0
    Bool mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
BYTE_argmax(byte *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    byte mp = *ip;
#if 0
    byte mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
UBYTE_argmax(ubyte *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    ubyte mp = *ip;
#if 0
    ubyte mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
SHORT_argmax(short *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    short mp = *ip;
#if 0
    short mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
USHORT_argmax(ushort *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    ushort mp = *ip;
#if 0
    ushort mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
INT_argmax(int *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    int mp = *ip;
#if 0
    int mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
UINT_argmax(uint *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    uint mp = *ip;
#if 0
    uint mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
LONG_argmax(long *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    long mp = *ip;
#if 0
    long mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
ULONG_argmax(ulong *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    ulong mp = *ip;
#if 0
    ulong mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
LONGLONG_argmax(longlong *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    longlong mp = *ip;
#if 0
    longlong mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
ULONGLONG_argmax(ulonglong *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    ulonglong mp = *ip;
#if 0
    ulonglong mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
HALF_argmax(npy_half *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    npy_half mp = *ip;
#if 0
    npy_half mp_im = ip[1];
#endif

    *max_ind = 0;

#if 1
    if (npy_half_isnan(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (npy_half_isnan(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || npy_half_isnan(ip[0]) || npy_half_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (npy_half_isnan(mp) || npy_half_isnan(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!npy_half_le(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 1
            if (npy_half_isnan(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
FLOAT_argmax(float *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    float mp = *ip;
#if 0
    float mp_im = ip[1];
#endif

    *max_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
DOUBLE_argmax(double *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    double mp = *ip;
#if 0
    double mp_im = ip[1];
#endif

    *max_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
LONGDOUBLE_argmax(longdouble *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    longdouble mp = *ip;
#if 0
    longdouble mp_im = ip[1];
#endif

    *max_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
CFLOAT_argmax(float *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    float mp = *ip;
#if 1
    float mp_im = ip[1];
#endif

    *max_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 1
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip+=2;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 1
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
CDOUBLE_argmax(double *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    double mp = *ip;
#if 1
    double mp_im = ip[1];
#endif

    *max_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 1
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip+=2;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 1
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
CLONGDOUBLE_argmax(longdouble *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    longdouble mp = *ip;
#if 1
    longdouble mp_im = ip[1];
#endif

    *max_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 1
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip+=2;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 1
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
DATETIME_argmax(datetime *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    datetime mp = *ip;
#if 0
    datetime mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2869
static int
TIMEDELTA_argmax(timedelta *ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    timedelta mp = *ip;
#if 0
    timedelta mp_im = ip[1];
#endif

    *max_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}



#line 2942
static int
BOOL_argmin(Bool *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    Bool mp = *ip;
#if 0
    Bool mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
BYTE_argmin(byte *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    byte mp = *ip;
#if 0
    byte mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
UBYTE_argmin(ubyte *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    ubyte mp = *ip;
#if 0
    ubyte mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
SHORT_argmin(short *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    short mp = *ip;
#if 0
    short mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
USHORT_argmin(ushort *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    ushort mp = *ip;
#if 0
    ushort mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
INT_argmin(int *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    int mp = *ip;
#if 0
    int mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
UINT_argmin(uint *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    uint mp = *ip;
#if 0
    uint mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
LONG_argmin(long *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    long mp = *ip;
#if 0
    long mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
ULONG_argmin(ulong *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    ulong mp = *ip;
#if 0
    ulong mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
LONGLONG_argmin(longlong *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    longlong mp = *ip;
#if 0
    longlong mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
ULONGLONG_argmin(ulonglong *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    ulonglong mp = *ip;
#if 0
    ulonglong mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
HALF_argmin(npy_half *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    npy_half mp = *ip;
#if 0
    npy_half mp_im = ip[1];
#endif

    *min_ind = 0;

#if 1
    if (npy_half_isnan(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (npy_half_isnan(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || npy_half_isnan(ip[0]) || npy_half_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (npy_half_isnan(mp) || npy_half_isnan(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!npy_half_le(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 1
            if (npy_half_isnan(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
FLOAT_argmin(float *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    float mp = *ip;
#if 0
    float mp_im = ip[1];
#endif

    *min_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
DOUBLE_argmin(double *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    double mp = *ip;
#if 0
    double mp_im = ip[1];
#endif

    *min_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
LONGDOUBLE_argmin(longdouble *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    longdouble mp = *ip;
#if 0
    longdouble mp_im = ip[1];
#endif

    *min_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
CFLOAT_argmin(float *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    float mp = *ip;
#if 1
    float mp_im = ip[1];
#endif

    *min_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 1
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip+=2;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 1
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
CDOUBLE_argmin(double *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    double mp = *ip;
#if 1
    double mp_im = ip[1];
#endif

    *min_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 1
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip+=2;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 1
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
CLONGDOUBLE_argmin(longdouble *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    longdouble mp = *ip;
#if 1
    longdouble mp_im = ip[1];
#endif

    *min_ind = 0;

#if 1
    if (npy_isnan(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 1
    if (npy_isnan(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip+=2;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 1
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || npy_isnan(ip[0]) || npy_isnan(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (npy_isnan(mp) || npy_isnan(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 1
            if (npy_isnan(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
DATETIME_argmin(datetime *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    datetime mp = *ip;
#if 0
    datetime mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}


#line 2942
static int
TIMEDELTA_argmin(timedelta *ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    timedelta mp = *ip;
#if 0
    timedelta mp_im = ip[1];
#endif

    *min_ind = 0;

#if 0
    if (nop(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if 0
    if (nop(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        ip++;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if 0
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || nop(ip[0]) || nop(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (nop(mp) || nop(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!_LESS_THAN_OR_EQUAL(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if 0
            if (nop(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}



#undef _LESS_THAN_OR_EQUAL

static int
OBJECT_argmax(PyObject **ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    PyObject *mp = ip[0];

    *max_ind = 0;
    i = 1;
    while (i < n && mp == NULL) {
        mp = ip[i];
        i++;
    }
    for (; i < n; i++) {
        ip++;
#if defined(NPY_PY3K)
        if (*ip != NULL && PyObject_RichCompareBool(*ip, mp, Py_GT) == 1) {
#else
        if (*ip != NULL && PyObject_Compare(*ip, mp) > 0) {
#endif
            mp = *ip;
            *max_ind = i;
        }
    }
    return 0;
}

#line 3034
static int
STRING_argmax(char *ip, intp n, intp *max_ind, PyArrayObject *aip)
{
    intp i;
    int elsize = aip->descr->elsize;
    char *mp = (char *)_pya_malloc(elsize);

    if (mp==NULL) return 0;
    memcpy(mp, ip, elsize);
    *max_ind = 0;
    for(i=1; i<n; i++) {
        ip += elsize;
        if (STRING_compare(ip,mp,aip) > 0) {
            memcpy(mp, ip, elsize);
            *max_ind=i;
        }
    }
    _pya_free(mp);
    return 0;
}


#line 3034
static int
UNICODE_argmax(PyArray_UCS4 *ip, intp n, intp *max_ind, PyArrayObject *aip)
{
    intp i;
    int elsize = aip->descr->elsize;
    PyArray_UCS4 *mp = (PyArray_UCS4 *)_pya_malloc(elsize);

    if (mp==NULL) return 0;
    memcpy(mp, ip, elsize);
    *max_ind = 0;
    for(i=1; i<n; i++) {
        ip += elsize;
        if (UNICODE_compare(ip,mp,aip) > 0) {
            memcpy(mp, ip, elsize);
            *max_ind=i;
        }
    }
    _pya_free(mp);
    return 0;
}



#define VOID_argmax NULL

static int
OBJECT_argmin(PyObject **ip, intp n, intp *min_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    PyObject *mp = ip[0];

    *min_ind = 0;
    i = 1;
    while (i < n && mp == NULL) {
        mp = ip[i];
        i++;
    }
    for (; i < n; i++) {
        ip++;
#if defined(NPY_PY3K)
        if (*ip != NULL && PyObject_RichCompareBool(mp, *ip, Py_GT) == 1) {
#else
        if (*ip != NULL && PyObject_Compare(mp, *ip) > 0) {
#endif
            mp = *ip;
            *min_ind = i;
        }
    }
    return 0;
}

#line 3090
static int
STRING_argmin(char *ip, intp n, intp *min_ind, PyArrayObject *aip)
{
    intp i;
    int elsize = PyArray_DESCR(aip)->elsize;
    char *mp = (char *)PyArray_malloc(elsize);

    if (mp==NULL) return 0;
    memcpy(mp, ip, elsize);
    *min_ind = 0;
    for(i=1; i<n; i++) {
        ip += elsize;
        if (STRING_compare(mp,ip,aip) > 0) {
            memcpy(mp, ip, elsize);
            *min_ind=i;
        }
    }
    PyArray_free(mp);
    return 0;
}


#line 3090
static int
UNICODE_argmin(PyArray_UCS4 *ip, intp n, intp *min_ind, PyArrayObject *aip)
{
    intp i;
    int elsize = PyArray_DESCR(aip)->elsize;
    PyArray_UCS4 *mp = (PyArray_UCS4 *)PyArray_malloc(elsize);

    if (mp==NULL) return 0;
    memcpy(mp, ip, elsize);
    *min_ind = 0;
    for(i=1; i<n; i++) {
        ip += elsize;
        if (UNICODE_compare(mp,ip,aip) > 0) {
            memcpy(mp, ip, elsize);
            *min_ind=i;
        }
    }
    PyArray_free(mp);
    return 0;
}




#define VOID_argmin NULL


/*
 *****************************************************************************
 **                                  DOT                                    **
 *****************************************************************************
 */

/*
 * dot means inner product
 */

static void
BOOL_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
         void *NPY_UNUSED(ignore))
{
    Bool tmp = FALSE;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        if ((*((Bool *)ip1) != 0) && (*((Bool *)ip2) != 0)) {
            tmp = TRUE;
            break;
        }
    }
    *((Bool *)op) = tmp;
}

#line 3155
static void
BYTE_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    long tmp = (long)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (long)(*((byte *)ip1)) *
               (long)(*((byte *)ip2));
    }
    *((byte *)op) = (byte) tmp;
}

#line 3155
static void
UBYTE_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    ulong tmp = (ulong)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (ulong)(*((ubyte *)ip1)) *
               (ulong)(*((ubyte *)ip2));
    }
    *((ubyte *)op) = (ubyte) tmp;
}

#line 3155
static void
SHORT_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    long tmp = (long)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (long)(*((short *)ip1)) *
               (long)(*((short *)ip2));
    }
    *((short *)op) = (short) tmp;
}

#line 3155
static void
USHORT_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    ulong tmp = (ulong)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (ulong)(*((ushort *)ip1)) *
               (ulong)(*((ushort *)ip2));
    }
    *((ushort *)op) = (ushort) tmp;
}

#line 3155
static void
INT_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    long tmp = (long)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (long)(*((int *)ip1)) *
               (long)(*((int *)ip2));
    }
    *((int *)op) = (int) tmp;
}

#line 3155
static void
UINT_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    ulong tmp = (ulong)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (ulong)(*((uint *)ip1)) *
               (ulong)(*((uint *)ip2));
    }
    *((uint *)op) = (uint) tmp;
}

#line 3155
static void
LONG_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    long tmp = (long)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (long)(*((long *)ip1)) *
               (long)(*((long *)ip2));
    }
    *((long *)op) = (long) tmp;
}

#line 3155
static void
ULONG_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    ulong tmp = (ulong)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (ulong)(*((ulong *)ip1)) *
               (ulong)(*((ulong *)ip2));
    }
    *((ulong *)op) = (ulong) tmp;
}

#line 3155
static void
LONGLONG_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    longlong tmp = (longlong)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (longlong)(*((longlong *)ip1)) *
               (longlong)(*((longlong *)ip2));
    }
    *((longlong *)op) = (longlong) tmp;
}

#line 3155
static void
ULONGLONG_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    ulonglong tmp = (ulonglong)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (ulonglong)(*((ulonglong *)ip1)) *
               (ulonglong)(*((ulonglong *)ip2));
    }
    *((ulonglong *)op) = (ulonglong) tmp;
}

#line 3155
static void
FLOAT_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    float tmp = (float)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (float)(*((float *)ip1)) *
               (float)(*((float *)ip2));
    }
    *((float *)op) = (float) tmp;
}

#line 3155
static void
DOUBLE_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    double tmp = (double)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (double)(*((double *)ip1)) *
               (double)(*((double *)ip2));
    }
    *((double *)op) = (double) tmp;
}

#line 3155
static void
LONGDOUBLE_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    longdouble tmp = (longdouble)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (longdouble)(*((longdouble *)ip1)) *
               (longdouble)(*((longdouble *)ip2));
    }
    *((longdouble *)op) = (longdouble) tmp;
}

#line 3155
static void
DATETIME_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    datetime tmp = (datetime)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (datetime)(*((datetime *)ip1)) *
               (datetime)(*((datetime *)ip2));
    }
    *((datetime *)op) = (datetime) tmp;
}

#line 3155
static void
TIMEDELTA_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    timedelta tmp = (timedelta)0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (timedelta)(*((timedelta *)ip1)) *
               (timedelta)(*((timedelta *)ip2));
    }
    *((timedelta *)op) = (timedelta) tmp;
}


static void
HALF_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op, npy_intp n,
           void *NPY_UNUSED(ignore))
{
    float tmp = 0.0f;
    npy_intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += npy_half_to_float(*((npy_half *)ip1)) *
               npy_half_to_float(*((npy_half *)ip2));
    }
    *((npy_half *)op) = npy_float_to_half(tmp);
}

#line 3189
static void CFLOAT_dot(char *ip1, intp is1, char *ip2, intp is2,
                       char *op, intp n, void *NPY_UNUSED(ignore))
{
    float tmpr = (float)0.0, tmpi=(float)0.0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmpr += ((float *)ip1)[0] * ((float *)ip2)[0]
                - ((float *)ip1)[1] * ((float *)ip2)[1];
        tmpi += ((float *)ip1)[1] * ((float *)ip2)[0]
                + ((float *)ip1)[0] * ((float *)ip2)[1];
    }
    ((float *)op)[0] = tmpr; ((float *)op)[1] = tmpi;
}


#line 3189
static void CDOUBLE_dot(char *ip1, intp is1, char *ip2, intp is2,
                       char *op, intp n, void *NPY_UNUSED(ignore))
{
    double tmpr = (double)0.0, tmpi=(double)0.0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmpr += ((double *)ip1)[0] * ((double *)ip2)[0]
                - ((double *)ip1)[1] * ((double *)ip2)[1];
        tmpi += ((double *)ip1)[1] * ((double *)ip2)[0]
                + ((double *)ip1)[0] * ((double *)ip2)[1];
    }
    ((double *)op)[0] = tmpr; ((double *)op)[1] = tmpi;
}


#line 3189
static void CLONGDOUBLE_dot(char *ip1, intp is1, char *ip2, intp is2,
                       char *op, intp n, void *NPY_UNUSED(ignore))
{
    longdouble tmpr = (longdouble)0.0, tmpi=(longdouble)0.0;
    intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmpr += ((longdouble *)ip1)[0] * ((longdouble *)ip2)[0]
                - ((longdouble *)ip1)[1] * ((longdouble *)ip2)[1];
        tmpi += ((longdouble *)ip1)[1] * ((longdouble *)ip2)[0]
                + ((longdouble *)ip1)[0] * ((longdouble *)ip2)[1];
    }
    ((longdouble *)op)[0] = tmpr; ((longdouble *)op)[1] = tmpi;
}



static void
OBJECT_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    /*
     * ALIGNMENT NOTE: np.dot, np.inner etc. enforce that the array is
     * BEHAVED before getting to this point, so unaligned pointers aren't
     * handled here.
     */
    intp i;
    PyObject *tmp1, *tmp2, *tmp = NULL;
    PyObject **tmp3;
    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        if ((*((PyObject **)ip1) == NULL) || (*((PyObject **)ip2) == NULL)) {
            tmp1 = Py_False;
            Py_INCREF(Py_False);
        }
        else {
            tmp1 = PyNumber_Multiply(*((PyObject **)ip1), *((PyObject **)ip2));
            if (!tmp1) {
                Py_XDECREF(tmp);
                return;
            }
        }
        if (i == 0) {
            tmp = tmp1;
        }
        else {
            tmp2 = PyNumber_Add(tmp, tmp1);
            Py_XDECREF(tmp);
            Py_XDECREF(tmp1);
            if (!tmp2) {
                return;
            }
            tmp = tmp2;
        }
    }
    tmp3 = (PyObject**) op;
    tmp2 = *tmp3;
    *((PyObject **)op) = tmp;
    Py_XDECREF(tmp2);
}


/*
 *****************************************************************************
 **                                 FILL                                    **
 *****************************************************************************
 */


#define BOOL_fill NULL

/* this requires buffer to be filled with objects or NULL */
static void
OBJECT_fill(PyObject **buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    PyObject *start = buffer[0];
    PyObject *delta = buffer[1];

    delta = PyNumber_Subtract(delta, start);
    if (!delta) {
        return;
    }
    start = PyNumber_Add(start, delta);
    if (!start) {
        goto finish;
    }
    buffer += 2;

    for (i = 2; i < length; i++, buffer++) {
        start = PyNumber_Add(start, delta);
        if (!start) {
            goto finish;
        }
        Py_XDECREF(*buffer);
        *buffer = start;
    }

finish:
    Py_DECREF(delta);
    return;
}

#line 3300
static void
BYTE_fill(byte *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    byte start = buffer[0];
    byte delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
UBYTE_fill(ubyte *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    ubyte start = buffer[0];
    ubyte delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
SHORT_fill(short *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    short start = buffer[0];
    short delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
USHORT_fill(ushort *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    ushort start = buffer[0];
    ushort delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
INT_fill(int *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    int start = buffer[0];
    int delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
UINT_fill(uint *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    uint start = buffer[0];
    uint delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
LONG_fill(long *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    long start = buffer[0];
    long delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
ULONG_fill(ulong *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    ulong start = buffer[0];
    ulong delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
LONGLONG_fill(longlong *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    longlong start = buffer[0];
    longlong delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
ULONGLONG_fill(ulonglong *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    ulonglong start = buffer[0];
    ulonglong delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
FLOAT_fill(float *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    float start = buffer[0];
    float delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
DOUBLE_fill(double *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    double start = buffer[0];
    double delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
LONGDOUBLE_fill(longdouble *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    longdouble start = buffer[0];
    longdouble delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
DATETIME_fill(datetime *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    datetime start = buffer[0];
    datetime delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}

#line 3300
static void
TIMEDELTA_fill(timedelta *buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    timedelta start = buffer[0];
    timedelta delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}


static void
HALF_fill(npy_half *buffer, npy_intp length, void *NPY_UNUSED(ignored))
{
    npy_intp i;
    float start = npy_half_to_float(buffer[0]);
    float delta = npy_half_to_float(buffer[1]);

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = npy_float_to_half(start + i*delta);
    }
}

#line 3332
static void
CFLOAT_fill(cfloat *buffer, intp length, void *NPY_UNUSED(ignore))
{
    intp i;
    cfloat start;
    cfloat delta;

    start.real = buffer->real;
    start.imag = buffer->imag;
    delta.real = buffer[1].real;
    delta.imag = buffer[1].imag;
    delta.real -= start.real;
    delta.imag -= start.imag;
    buffer += 2;
    for (i = 2; i < length; i++, buffer++) {
        buffer->real = start.real + i*delta.real;
        buffer->imag = start.imag + i*delta.imag;
    }
}

#line 3332
static void
CDOUBLE_fill(cdouble *buffer, intp length, void *NPY_UNUSED(ignore))
{
    intp i;
    cdouble start;
    cdouble delta;

    start.real = buffer->real;
    start.imag = buffer->imag;
    delta.real = buffer[1].real;
    delta.imag = buffer[1].imag;
    delta.real -= start.real;
    delta.imag -= start.imag;
    buffer += 2;
    for (i = 2; i < length; i++, buffer++) {
        buffer->real = start.real + i*delta.real;
        buffer->imag = start.imag + i*delta.imag;
    }
}

#line 3332
static void
CLONGDOUBLE_fill(clongdouble *buffer, intp length, void *NPY_UNUSED(ignore))
{
    intp i;
    clongdouble start;
    clongdouble delta;

    start.real = buffer->real;
    start.imag = buffer->imag;
    delta.real = buffer[1].real;
    delta.imag = buffer[1].imag;
    delta.real -= start.real;
    delta.imag -= start.imag;
    buffer += 2;
    for (i = 2; i < length; i++, buffer++) {
        buffer->real = start.real + i*delta.real;
        buffer->imag = start.imag + i*delta.imag;
    }
}



/* this requires buffer to be filled with objects or NULL */
static void
OBJECT_fillwithscalar(PyObject **buffer, intp length, PyObject **value, void *NPY_UNUSED(ignored))
{
    intp i;
    PyObject *val = *value;
    for (i = 0; i < length; i++) {
        Py_XDECREF(buffer[i]);
        Py_XINCREF(val);
        buffer[i] = val;
    }
}
#line 3371
static void
BOOL_fillwithscalar(Bool *buffer, intp length, Bool *value, void *NPY_UNUSED(ignored))
{
    memset(buffer, *value, length);
}

#line 3371
static void
BYTE_fillwithscalar(byte *buffer, intp length, byte *value, void *NPY_UNUSED(ignored))
{
    memset(buffer, *value, length);
}

#line 3371
static void
UBYTE_fillwithscalar(ubyte *buffer, intp length, ubyte *value, void *NPY_UNUSED(ignored))
{
    memset(buffer, *value, length);
}


#line 3387
static void
SHORT_fillwithscalar(short *buffer, intp length, short *value, void *NPY_UNUSED(ignored))
{
    intp i;
    short val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
USHORT_fillwithscalar(ushort *buffer, intp length, ushort *value, void *NPY_UNUSED(ignored))
{
    intp i;
    ushort val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
INT_fillwithscalar(int *buffer, intp length, int *value, void *NPY_UNUSED(ignored))
{
    intp i;
    int val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
UINT_fillwithscalar(uint *buffer, intp length, uint *value, void *NPY_UNUSED(ignored))
{
    intp i;
    uint val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
LONG_fillwithscalar(long *buffer, intp length, long *value, void *NPY_UNUSED(ignored))
{
    intp i;
    long val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
ULONG_fillwithscalar(ulong *buffer, intp length, ulong *value, void *NPY_UNUSED(ignored))
{
    intp i;
    ulong val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
LONGLONG_fillwithscalar(longlong *buffer, intp length, longlong *value, void *NPY_UNUSED(ignored))
{
    intp i;
    longlong val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
ULONGLONG_fillwithscalar(ulonglong *buffer, intp length, ulonglong *value, void *NPY_UNUSED(ignored))
{
    intp i;
    ulonglong val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
HALF_fillwithscalar(npy_half *buffer, intp length, npy_half *value, void *NPY_UNUSED(ignored))
{
    intp i;
    npy_half val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
FLOAT_fillwithscalar(float *buffer, intp length, float *value, void *NPY_UNUSED(ignored))
{
    intp i;
    float val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
DOUBLE_fillwithscalar(double *buffer, intp length, double *value, void *NPY_UNUSED(ignored))
{
    intp i;
    double val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
LONGDOUBLE_fillwithscalar(longdouble *buffer, intp length, longdouble *value, void *NPY_UNUSED(ignored))
{
    intp i;
    longdouble val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
CFLOAT_fillwithscalar(cfloat *buffer, intp length, cfloat *value, void *NPY_UNUSED(ignored))
{
    intp i;
    cfloat val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
CDOUBLE_fillwithscalar(cdouble *buffer, intp length, cdouble *value, void *NPY_UNUSED(ignored))
{
    intp i;
    cdouble val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
CLONGDOUBLE_fillwithscalar(clongdouble *buffer, intp length, clongdouble *value, void *NPY_UNUSED(ignored))
{
    intp i;
    clongdouble val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
DATETIME_fillwithscalar(datetime *buffer, intp length, datetime *value, void *NPY_UNUSED(ignored))
{
    intp i;
    datetime val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}

#line 3387
static void
TIMEDELTA_fillwithscalar(timedelta *buffer, intp length, timedelta *value, void *NPY_UNUSED(ignored))
{
    intp i;
    timedelta val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}



/*
 *****************************************************************************
 **                               FASTCLIP                                  **
 *****************************************************************************
 */

#define _LESS_THAN(a, b) ((a) < (b))
#define _GREATER_THAN(a, b) ((a) > (b))
/*
 * In fastclip, 'b' was already checked for NaN, so the half comparison
 * only needs to check 'a' for NaN.
 */
#define _HALF_LESS_THAN(a, b) (!npy_half_isnan(a) && npy_half_lt_nonan(a, b))
#define _HALF_GREATER_THAN(a, b) (!npy_half_isnan(a) && npy_half_lt_nonan(b, a))

#line 3428
static void
BOOL_fastclip(Bool *in, intp ni, Bool *min, Bool *max, Bool *out)
{
    npy_intp i;
    Bool max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
BYTE_fastclip(byte *in, intp ni, byte *min, byte *max, byte *out)
{
    npy_intp i;
    byte max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
UBYTE_fastclip(ubyte *in, intp ni, ubyte *min, ubyte *max, ubyte *out)
{
    npy_intp i;
    ubyte max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
SHORT_fastclip(short *in, intp ni, short *min, short *max, short *out)
{
    npy_intp i;
    short max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
USHORT_fastclip(ushort *in, intp ni, ushort *min, ushort *max, ushort *out)
{
    npy_intp i;
    ushort max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
INT_fastclip(int *in, intp ni, int *min, int *max, int *out)
{
    npy_intp i;
    int max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
UINT_fastclip(uint *in, intp ni, uint *min, uint *max, uint *out)
{
    npy_intp i;
    uint max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
LONG_fastclip(long *in, intp ni, long *min, long *max, long *out)
{
    npy_intp i;
    long max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
ULONG_fastclip(ulong *in, intp ni, ulong *min, ulong *max, ulong *out)
{
    npy_intp i;
    ulong max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
LONGLONG_fastclip(longlong *in, intp ni, longlong *min, longlong *max, longlong *out)
{
    npy_intp i;
    longlong max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
ULONGLONG_fastclip(ulonglong *in, intp ni, ulonglong *min, ulonglong *max, ulonglong *out)
{
    npy_intp i;
    ulonglong max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
HALF_fastclip(npy_half *in, intp ni, npy_half *min, npy_half *max, npy_half *out)
{
    npy_intp i;
    npy_half max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 1
        /* NaNs result in no clipping, so optimize the case away */
        if (npy_half_isnan(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 1
        if (npy_half_isnan(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_HALF_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_HALF_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_HALF_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_HALF_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
FLOAT_fastclip(float *in, intp ni, float *min, float *max, float *out)
{
    npy_intp i;
    float max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 1
        /* NaNs result in no clipping, so optimize the case away */
        if (npy_isnan(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 1
        if (npy_isnan(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
DOUBLE_fastclip(double *in, intp ni, double *min, double *max, double *out)
{
    npy_intp i;
    double max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 1
        /* NaNs result in no clipping, so optimize the case away */
        if (npy_isnan(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 1
        if (npy_isnan(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
LONGDOUBLE_fastclip(longdouble *in, intp ni, longdouble *min, longdouble *max, longdouble *out)
{
    npy_intp i;
    longdouble max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 1
        /* NaNs result in no clipping, so optimize the case away */
        if (npy_isnan(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 1
        if (npy_isnan(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
DATETIME_fastclip(datetime *in, intp ni, datetime *min, datetime *max, datetime *out)
{
    npy_intp i;
    datetime max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}

#line 3428
static void
TIMEDELTA_fastclip(timedelta *in, intp ni, timedelta *min, timedelta *max, timedelta *out)
{
    npy_intp i;
    timedelta max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if 0
        /* NaNs result in no clipping, so optimize the case away */
        if (nop(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if 0
        if (nop(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (_GREATER_THAN(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (_LESS_THAN(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (_GREATER_THAN(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}


#undef _LESS_THAN
#undef _GREATER_THAN
#undef _HALF_LESS_THAN
#undef _HALF_GREATER_THAN

#line 3494
static void
CFLOAT_fastclip(cfloat *in, intp ni, cfloat *min, cfloat *max, cfloat *out)
{
    npy_intp i;
    cfloat max_val, min_val;

    min_val = *min;
    max_val = *max;
    if (max != NULL) {
        max_val = *max;
    }
    if (min != NULL) {
        min_val = *min;
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i],min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i], min_val)) {
                out[i] = min_val;
            }
            else if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
}


#line 3494
static void
CDOUBLE_fastclip(cdouble *in, intp ni, cdouble *min, cdouble *max, cdouble *out)
{
    npy_intp i;
    cdouble max_val, min_val;

    min_val = *min;
    max_val = *max;
    if (max != NULL) {
        max_val = *max;
    }
    if (min != NULL) {
        min_val = *min;
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i],min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i], min_val)) {
                out[i] = min_val;
            }
            else if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
}


#line 3494
static void
CLONGDOUBLE_fastclip(clongdouble *in, intp ni, clongdouble *min, clongdouble *max, clongdouble *out)
{
    npy_intp i;
    clongdouble max_val, min_val;

    min_val = *min;
    max_val = *max;
    if (max != NULL) {
        max_val = *max;
    }
    if (min != NULL) {
        min_val = *min;
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i],min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i], min_val)) {
                out[i] = min_val;
            }
            else if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
}



#define OBJECT_fastclip NULL


/*
 *****************************************************************************
 **                              FASTPUTMASK                                **
 *****************************************************************************
 */


#line 3555
static void
BOOL_fastputmask(Bool *in, Bool *mask, intp ni, Bool *vals, intp nv)
{
    npy_intp i;
    Bool s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
BYTE_fastputmask(byte *in, Bool *mask, intp ni, byte *vals, intp nv)
{
    npy_intp i;
    byte s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
UBYTE_fastputmask(ubyte *in, Bool *mask, intp ni, ubyte *vals, intp nv)
{
    npy_intp i;
    ubyte s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
SHORT_fastputmask(short *in, Bool *mask, intp ni, short *vals, intp nv)
{
    npy_intp i;
    short s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
USHORT_fastputmask(ushort *in, Bool *mask, intp ni, ushort *vals, intp nv)
{
    npy_intp i;
    ushort s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
INT_fastputmask(int *in, Bool *mask, intp ni, int *vals, intp nv)
{
    npy_intp i;
    int s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
UINT_fastputmask(uint *in, Bool *mask, intp ni, uint *vals, intp nv)
{
    npy_intp i;
    uint s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
LONG_fastputmask(long *in, Bool *mask, intp ni, long *vals, intp nv)
{
    npy_intp i;
    long s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
ULONG_fastputmask(ulong *in, Bool *mask, intp ni, ulong *vals, intp nv)
{
    npy_intp i;
    ulong s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
LONGLONG_fastputmask(longlong *in, Bool *mask, intp ni, longlong *vals, intp nv)
{
    npy_intp i;
    longlong s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
ULONGLONG_fastputmask(ulonglong *in, Bool *mask, intp ni, ulonglong *vals, intp nv)
{
    npy_intp i;
    ulonglong s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
HALF_fastputmask(npy_half *in, Bool *mask, intp ni, npy_half *vals, intp nv)
{
    npy_intp i;
    npy_half s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
FLOAT_fastputmask(float *in, Bool *mask, intp ni, float *vals, intp nv)
{
    npy_intp i;
    float s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
DOUBLE_fastputmask(double *in, Bool *mask, intp ni, double *vals, intp nv)
{
    npy_intp i;
    double s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
LONGDOUBLE_fastputmask(longdouble *in, Bool *mask, intp ni, longdouble *vals, intp nv)
{
    npy_intp i;
    longdouble s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
CFLOAT_fastputmask(cfloat *in, Bool *mask, intp ni, cfloat *vals, intp nv)
{
    npy_intp i;
    cfloat s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
CDOUBLE_fastputmask(cdouble *in, Bool *mask, intp ni, cdouble *vals, intp nv)
{
    npy_intp i;
    cdouble s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
CLONGDOUBLE_fastputmask(clongdouble *in, Bool *mask, intp ni, clongdouble *vals, intp nv)
{
    npy_intp i;
    clongdouble s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
DATETIME_fastputmask(datetime *in, Bool *mask, intp ni, datetime *vals, intp nv)
{
    npy_intp i;
    datetime s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}

#line 3555
static void
TIMEDELTA_fastputmask(timedelta *in, Bool *mask, intp ni, timedelta *vals, intp nv)
{
    npy_intp i;
    timedelta s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}


#define OBJECT_fastputmask NULL


/*
 *****************************************************************************
 **                                FASTTAKE                                 **
 *****************************************************************************
 */


#line 3599
static int
BOOL_fasttake(Bool *dest, Bool *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
BYTE_fasttake(byte *dest, byte *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
UBYTE_fasttake(ubyte *dest, ubyte *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
SHORT_fasttake(short *dest, short *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
USHORT_fasttake(ushort *dest, ushort *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
INT_fasttake(int *dest, int *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
UINT_fasttake(uint *dest, uint *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
LONG_fasttake(long *dest, long *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
ULONG_fasttake(ulong *dest, ulong *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
LONGLONG_fasttake(longlong *dest, longlong *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
ULONGLONG_fasttake(ulonglong *dest, ulonglong *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
HALF_fasttake(npy_half *dest, npy_half *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
FLOAT_fasttake(float *dest, float *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
DOUBLE_fasttake(double *dest, double *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
LONGDOUBLE_fasttake(longdouble *dest, longdouble *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
CFLOAT_fasttake(cfloat *dest, cfloat *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
CDOUBLE_fasttake(cdouble *dest, cdouble *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
CLONGDOUBLE_fasttake(clongdouble *dest, clongdouble *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
DATETIME_fasttake(datetime *dest, datetime *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}

#line 3599
static int
TIMEDELTA_fasttake(timedelta *dest, timedelta *src, intp *indarray,
                    intp nindarray, intp n_outer,
                    intp m_middle, intp nelem,
                    NPY_CLIPMODE clipmode)
{
    intp i, j, k, tmp;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = tmp+nindarray;
                }
                if ((tmp < 0) || (tmp >= nindarray)) {
                    PyErr_SetString(PyExc_IndexError,
                                    "index out of range for array");
                    return 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (nelem == 1) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }
    return 0;
}


#define OBJECT_fasttake NULL


/*
 *****************************************************************************
 **                       SETUP FUNCTION POINTERS                           **
 *****************************************************************************
 */


#define _ALIGN(type) offsetof(struct {char c; type v;}, v)
/*
 * Disable harmless compiler warning "4116: unnamed type definition in
 * parentheses" which is caused by the _ALIGN macro.
 */
#if defined(_MSC_VER)
#pragma warning(disable:4116)
#endif


#line 3712
static PyArray_ArrFuncs _PyVoid_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)VOID_to_BOOL,
        (PyArray_VectorUnaryFunc*)VOID_to_BYTE,
        (PyArray_VectorUnaryFunc*)VOID_to_UBYTE,
        (PyArray_VectorUnaryFunc*)VOID_to_SHORT,
        (PyArray_VectorUnaryFunc*)VOID_to_USHORT,
        (PyArray_VectorUnaryFunc*)VOID_to_INT,
        (PyArray_VectorUnaryFunc*)VOID_to_UINT,
        (PyArray_VectorUnaryFunc*)VOID_to_LONG,
        (PyArray_VectorUnaryFunc*)VOID_to_ULONG,
        (PyArray_VectorUnaryFunc*)VOID_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)VOID_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)VOID_to_FLOAT,
        (PyArray_VectorUnaryFunc*)VOID_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)VOID_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)VOID_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)VOID_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)VOID_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)VOID_to_OBJECT,
        (PyArray_VectorUnaryFunc*)VOID_to_STRING,
        (PyArray_VectorUnaryFunc*)VOID_to_UNICODE,
        (PyArray_VectorUnaryFunc*)VOID_to_VOID
    },
    (PyArray_GetItemFunc*)VOID_getitem,
    (PyArray_SetItemFunc*)VOID_setitem,
    (PyArray_CopySwapNFunc*)VOID_copyswapn,
    (PyArray_CopySwapFunc*)VOID_copyswap,
    (PyArray_CompareFunc*)VOID_compare,
    (PyArray_ArgFunc*)VOID_argmax,
    (PyArray_DotFunc*)NULL,
    (PyArray_ScanFunc*)VOID_scan,
    (PyArray_FromStrFunc*)VOID_fromstr,
    (PyArray_NonzeroFunc*)VOID_nonzero,
    (PyArray_FillFunc*)NULL,
    (PyArray_FillWithScalarFunc*)NULL,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc *)NULL,
    (PyArray_FastPutmaskFunc *)NULL,
    (PyArray_FastTakeFunc *)NULL,
    (PyArray_ArgFunc*)VOID_argmin
};

/*
 * FIXME: check for PY3K
 */
static PyArray_Descr VOID_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyVoidArrType_Type,
    PyArray_VOIDLTR,
    PyArray_VOIDLTR,
    '|',
    0,
    PyArray_VOID,
    0,
    _ALIGN(char),
    NULL,
    NULL,
    NULL,
    &_PyVoid_ArrFuncs,
    NULL,
};


#line 3712
static PyArray_ArrFuncs _PyString_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)STRING_to_BOOL,
        (PyArray_VectorUnaryFunc*)STRING_to_BYTE,
        (PyArray_VectorUnaryFunc*)STRING_to_UBYTE,
        (PyArray_VectorUnaryFunc*)STRING_to_SHORT,
        (PyArray_VectorUnaryFunc*)STRING_to_USHORT,
        (PyArray_VectorUnaryFunc*)STRING_to_INT,
        (PyArray_VectorUnaryFunc*)STRING_to_UINT,
        (PyArray_VectorUnaryFunc*)STRING_to_LONG,
        (PyArray_VectorUnaryFunc*)STRING_to_ULONG,
        (PyArray_VectorUnaryFunc*)STRING_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)STRING_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)STRING_to_FLOAT,
        (PyArray_VectorUnaryFunc*)STRING_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)STRING_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)STRING_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)STRING_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)STRING_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)STRING_to_OBJECT,
        (PyArray_VectorUnaryFunc*)STRING_to_STRING,
        (PyArray_VectorUnaryFunc*)STRING_to_UNICODE,
        (PyArray_VectorUnaryFunc*)STRING_to_VOID
    },
    (PyArray_GetItemFunc*)STRING_getitem,
    (PyArray_SetItemFunc*)STRING_setitem,
    (PyArray_CopySwapNFunc*)STRING_copyswapn,
    (PyArray_CopySwapFunc*)STRING_copyswap,
    (PyArray_CompareFunc*)STRING_compare,
    (PyArray_ArgFunc*)STRING_argmax,
    (PyArray_DotFunc*)NULL,
    (PyArray_ScanFunc*)STRING_scan,
    (PyArray_FromStrFunc*)STRING_fromstr,
    (PyArray_NonzeroFunc*)STRING_nonzero,
    (PyArray_FillFunc*)NULL,
    (PyArray_FillWithScalarFunc*)NULL,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc *)NULL,
    (PyArray_FastPutmaskFunc *)NULL,
    (PyArray_FastTakeFunc *)NULL,
    (PyArray_ArgFunc*)STRING_argmin
};

/*
 * FIXME: check for PY3K
 */
static PyArray_Descr STRING_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyStringArrType_Type,
    PyArray_STRINGLTR,
    PyArray_STRINGLTR,
    '|',
    0,
    PyArray_STRING,
    0,
    _ALIGN(char),
    NULL,
    NULL,
    NULL,
    &_PyString_ArrFuncs,
    NULL,
};


#line 3712
static PyArray_ArrFuncs _PyUnicode_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)UNICODE_to_BOOL,
        (PyArray_VectorUnaryFunc*)UNICODE_to_BYTE,
        (PyArray_VectorUnaryFunc*)UNICODE_to_UBYTE,
        (PyArray_VectorUnaryFunc*)UNICODE_to_SHORT,
        (PyArray_VectorUnaryFunc*)UNICODE_to_USHORT,
        (PyArray_VectorUnaryFunc*)UNICODE_to_INT,
        (PyArray_VectorUnaryFunc*)UNICODE_to_UINT,
        (PyArray_VectorUnaryFunc*)UNICODE_to_LONG,
        (PyArray_VectorUnaryFunc*)UNICODE_to_ULONG,
        (PyArray_VectorUnaryFunc*)UNICODE_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)UNICODE_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)UNICODE_to_FLOAT,
        (PyArray_VectorUnaryFunc*)UNICODE_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)UNICODE_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)UNICODE_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)UNICODE_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)UNICODE_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)UNICODE_to_OBJECT,
        (PyArray_VectorUnaryFunc*)UNICODE_to_STRING,
        (PyArray_VectorUnaryFunc*)UNICODE_to_UNICODE,
        (PyArray_VectorUnaryFunc*)UNICODE_to_VOID
    },
    (PyArray_GetItemFunc*)UNICODE_getitem,
    (PyArray_SetItemFunc*)UNICODE_setitem,
    (PyArray_CopySwapNFunc*)UNICODE_copyswapn,
    (PyArray_CopySwapFunc*)UNICODE_copyswap,
    (PyArray_CompareFunc*)UNICODE_compare,
    (PyArray_ArgFunc*)UNICODE_argmax,
    (PyArray_DotFunc*)NULL,
    (PyArray_ScanFunc*)UNICODE_scan,
    (PyArray_FromStrFunc*)UNICODE_fromstr,
    (PyArray_NonzeroFunc*)UNICODE_nonzero,
    (PyArray_FillFunc*)NULL,
    (PyArray_FillWithScalarFunc*)NULL,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc *)NULL,
    (PyArray_FastPutmaskFunc *)NULL,
    (PyArray_FastTakeFunc *)NULL,
    (PyArray_ArgFunc*)UNICODE_argmin
};

/*
 * FIXME: check for PY3K
 */
static PyArray_Descr UNICODE_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyUnicodeArrType_Type,
    PyArray_UNICODELTR,
    PyArray_UNICODELTR,
    '=',
    0,
    PyArray_UNICODE,
    0,
    _ALIGN(PyArray_UCS4),
    NULL,
    NULL,
    NULL,
    &_PyUnicode_ArrFuncs,
    NULL,
};



#line 3804
static PyArray_ArrFuncs _PyBool_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)BOOL_to_BOOL,
        (PyArray_VectorUnaryFunc*)BOOL_to_BYTE,
        (PyArray_VectorUnaryFunc*)BOOL_to_UBYTE,
        (PyArray_VectorUnaryFunc*)BOOL_to_SHORT,
        (PyArray_VectorUnaryFunc*)BOOL_to_USHORT,
        (PyArray_VectorUnaryFunc*)BOOL_to_INT,
        (PyArray_VectorUnaryFunc*)BOOL_to_UINT,
        (PyArray_VectorUnaryFunc*)BOOL_to_LONG,
        (PyArray_VectorUnaryFunc*)BOOL_to_ULONG,
        (PyArray_VectorUnaryFunc*)BOOL_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)BOOL_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)BOOL_to_FLOAT,
        (PyArray_VectorUnaryFunc*)BOOL_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)BOOL_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)BOOL_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)BOOL_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)BOOL_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)BOOL_to_OBJECT,
        (PyArray_VectorUnaryFunc*)BOOL_to_STRING,
        (PyArray_VectorUnaryFunc*)BOOL_to_UNICODE,
        (PyArray_VectorUnaryFunc*)BOOL_to_VOID
    },
    (PyArray_GetItemFunc*)BOOL_getitem,
    (PyArray_SetItemFunc*)BOOL_setitem,
    (PyArray_CopySwapNFunc*)BOOL_copyswapn,
    (PyArray_CopySwapFunc*)BOOL_copyswap,
    (PyArray_CompareFunc*)BOOL_compare,
    (PyArray_ArgFunc*)BOOL_argmax,
    (PyArray_DotFunc*)BOOL_dot,
    (PyArray_ScanFunc*)BOOL_scan,
    (PyArray_FromStrFunc*)BOOL_fromstr,
    (PyArray_NonzeroFunc*)BOOL_nonzero,
    (PyArray_FillFunc*)BOOL_fill,
    (PyArray_FillWithScalarFunc*)BOOL_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)BOOL_fastclip,
    (PyArray_FastPutmaskFunc*)BOOL_fastputmask,
    (PyArray_FastTakeFunc*)BOOL_fasttake,
    (PyArray_ArgFunc*)BOOL_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr BOOL_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyBoolArrType_Type,
    PyArray_GENBOOLLTR,
    PyArray_BOOLLTR,
    '|',
    0,
    PyArray_BOOL,
    1*sizeof(Bool),
    _ALIGN(Bool),
    NULL,
    NULL,
    NULL,
    &_PyBool_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyByte_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)BYTE_to_BOOL,
        (PyArray_VectorUnaryFunc*)BYTE_to_BYTE,
        (PyArray_VectorUnaryFunc*)BYTE_to_UBYTE,
        (PyArray_VectorUnaryFunc*)BYTE_to_SHORT,
        (PyArray_VectorUnaryFunc*)BYTE_to_USHORT,
        (PyArray_VectorUnaryFunc*)BYTE_to_INT,
        (PyArray_VectorUnaryFunc*)BYTE_to_UINT,
        (PyArray_VectorUnaryFunc*)BYTE_to_LONG,
        (PyArray_VectorUnaryFunc*)BYTE_to_ULONG,
        (PyArray_VectorUnaryFunc*)BYTE_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)BYTE_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)BYTE_to_FLOAT,
        (PyArray_VectorUnaryFunc*)BYTE_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)BYTE_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)BYTE_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)BYTE_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)BYTE_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)BYTE_to_OBJECT,
        (PyArray_VectorUnaryFunc*)BYTE_to_STRING,
        (PyArray_VectorUnaryFunc*)BYTE_to_UNICODE,
        (PyArray_VectorUnaryFunc*)BYTE_to_VOID
    },
    (PyArray_GetItemFunc*)BYTE_getitem,
    (PyArray_SetItemFunc*)BYTE_setitem,
    (PyArray_CopySwapNFunc*)BYTE_copyswapn,
    (PyArray_CopySwapFunc*)BYTE_copyswap,
    (PyArray_CompareFunc*)BYTE_compare,
    (PyArray_ArgFunc*)BYTE_argmax,
    (PyArray_DotFunc*)BYTE_dot,
    (PyArray_ScanFunc*)BYTE_scan,
    (PyArray_FromStrFunc*)BYTE_fromstr,
    (PyArray_NonzeroFunc*)BYTE_nonzero,
    (PyArray_FillFunc*)BYTE_fill,
    (PyArray_FillWithScalarFunc*)BYTE_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)BYTE_fastclip,
    (PyArray_FastPutmaskFunc*)BYTE_fastputmask,
    (PyArray_FastTakeFunc*)BYTE_fasttake,
    (PyArray_ArgFunc*)BYTE_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr BYTE_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyByteArrType_Type,
    PyArray_SIGNEDLTR,
    PyArray_BYTELTR,
    '|',
    0,
    PyArray_BYTE,
    1*sizeof(byte),
    _ALIGN(byte),
    NULL,
    NULL,
    NULL,
    &_PyByte_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyUByte_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)UBYTE_to_BOOL,
        (PyArray_VectorUnaryFunc*)UBYTE_to_BYTE,
        (PyArray_VectorUnaryFunc*)UBYTE_to_UBYTE,
        (PyArray_VectorUnaryFunc*)UBYTE_to_SHORT,
        (PyArray_VectorUnaryFunc*)UBYTE_to_USHORT,
        (PyArray_VectorUnaryFunc*)UBYTE_to_INT,
        (PyArray_VectorUnaryFunc*)UBYTE_to_UINT,
        (PyArray_VectorUnaryFunc*)UBYTE_to_LONG,
        (PyArray_VectorUnaryFunc*)UBYTE_to_ULONG,
        (PyArray_VectorUnaryFunc*)UBYTE_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)UBYTE_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)UBYTE_to_FLOAT,
        (PyArray_VectorUnaryFunc*)UBYTE_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)UBYTE_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)UBYTE_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)UBYTE_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)UBYTE_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)UBYTE_to_OBJECT,
        (PyArray_VectorUnaryFunc*)UBYTE_to_STRING,
        (PyArray_VectorUnaryFunc*)UBYTE_to_UNICODE,
        (PyArray_VectorUnaryFunc*)UBYTE_to_VOID
    },
    (PyArray_GetItemFunc*)UBYTE_getitem,
    (PyArray_SetItemFunc*)UBYTE_setitem,
    (PyArray_CopySwapNFunc*)UBYTE_copyswapn,
    (PyArray_CopySwapFunc*)UBYTE_copyswap,
    (PyArray_CompareFunc*)UBYTE_compare,
    (PyArray_ArgFunc*)UBYTE_argmax,
    (PyArray_DotFunc*)UBYTE_dot,
    (PyArray_ScanFunc*)UBYTE_scan,
    (PyArray_FromStrFunc*)UBYTE_fromstr,
    (PyArray_NonzeroFunc*)UBYTE_nonzero,
    (PyArray_FillFunc*)UBYTE_fill,
    (PyArray_FillWithScalarFunc*)UBYTE_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)UBYTE_fastclip,
    (PyArray_FastPutmaskFunc*)UBYTE_fastputmask,
    (PyArray_FastTakeFunc*)UBYTE_fasttake,
    (PyArray_ArgFunc*)UBYTE_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr UBYTE_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyUByteArrType_Type,
    PyArray_UNSIGNEDLTR,
    PyArray_UBYTELTR,
    '|',
    0,
    PyArray_UBYTE,
    1*sizeof(ubyte),
    _ALIGN(ubyte),
    NULL,
    NULL,
    NULL,
    &_PyUByte_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyShort_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)SHORT_to_BOOL,
        (PyArray_VectorUnaryFunc*)SHORT_to_BYTE,
        (PyArray_VectorUnaryFunc*)SHORT_to_UBYTE,
        (PyArray_VectorUnaryFunc*)SHORT_to_SHORT,
        (PyArray_VectorUnaryFunc*)SHORT_to_USHORT,
        (PyArray_VectorUnaryFunc*)SHORT_to_INT,
        (PyArray_VectorUnaryFunc*)SHORT_to_UINT,
        (PyArray_VectorUnaryFunc*)SHORT_to_LONG,
        (PyArray_VectorUnaryFunc*)SHORT_to_ULONG,
        (PyArray_VectorUnaryFunc*)SHORT_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)SHORT_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)SHORT_to_FLOAT,
        (PyArray_VectorUnaryFunc*)SHORT_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)SHORT_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)SHORT_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)SHORT_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)SHORT_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)SHORT_to_OBJECT,
        (PyArray_VectorUnaryFunc*)SHORT_to_STRING,
        (PyArray_VectorUnaryFunc*)SHORT_to_UNICODE,
        (PyArray_VectorUnaryFunc*)SHORT_to_VOID
    },
    (PyArray_GetItemFunc*)SHORT_getitem,
    (PyArray_SetItemFunc*)SHORT_setitem,
    (PyArray_CopySwapNFunc*)SHORT_copyswapn,
    (PyArray_CopySwapFunc*)SHORT_copyswap,
    (PyArray_CompareFunc*)SHORT_compare,
    (PyArray_ArgFunc*)SHORT_argmax,
    (PyArray_DotFunc*)SHORT_dot,
    (PyArray_ScanFunc*)SHORT_scan,
    (PyArray_FromStrFunc*)SHORT_fromstr,
    (PyArray_NonzeroFunc*)SHORT_nonzero,
    (PyArray_FillFunc*)SHORT_fill,
    (PyArray_FillWithScalarFunc*)SHORT_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)SHORT_fastclip,
    (PyArray_FastPutmaskFunc*)SHORT_fastputmask,
    (PyArray_FastTakeFunc*)SHORT_fasttake,
    (PyArray_ArgFunc*)SHORT_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr SHORT_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyShortArrType_Type,
    PyArray_SIGNEDLTR,
    PyArray_SHORTLTR,
    '=',
    0,
    PyArray_SHORT,
    1*sizeof(short),
    _ALIGN(short),
    NULL,
    NULL,
    NULL,
    &_PyShort_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyUShort_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)USHORT_to_BOOL,
        (PyArray_VectorUnaryFunc*)USHORT_to_BYTE,
        (PyArray_VectorUnaryFunc*)USHORT_to_UBYTE,
        (PyArray_VectorUnaryFunc*)USHORT_to_SHORT,
        (PyArray_VectorUnaryFunc*)USHORT_to_USHORT,
        (PyArray_VectorUnaryFunc*)USHORT_to_INT,
        (PyArray_VectorUnaryFunc*)USHORT_to_UINT,
        (PyArray_VectorUnaryFunc*)USHORT_to_LONG,
        (PyArray_VectorUnaryFunc*)USHORT_to_ULONG,
        (PyArray_VectorUnaryFunc*)USHORT_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)USHORT_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)USHORT_to_FLOAT,
        (PyArray_VectorUnaryFunc*)USHORT_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)USHORT_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)USHORT_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)USHORT_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)USHORT_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)USHORT_to_OBJECT,
        (PyArray_VectorUnaryFunc*)USHORT_to_STRING,
        (PyArray_VectorUnaryFunc*)USHORT_to_UNICODE,
        (PyArray_VectorUnaryFunc*)USHORT_to_VOID
    },
    (PyArray_GetItemFunc*)USHORT_getitem,
    (PyArray_SetItemFunc*)USHORT_setitem,
    (PyArray_CopySwapNFunc*)USHORT_copyswapn,
    (PyArray_CopySwapFunc*)USHORT_copyswap,
    (PyArray_CompareFunc*)USHORT_compare,
    (PyArray_ArgFunc*)USHORT_argmax,
    (PyArray_DotFunc*)USHORT_dot,
    (PyArray_ScanFunc*)USHORT_scan,
    (PyArray_FromStrFunc*)USHORT_fromstr,
    (PyArray_NonzeroFunc*)USHORT_nonzero,
    (PyArray_FillFunc*)USHORT_fill,
    (PyArray_FillWithScalarFunc*)USHORT_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)USHORT_fastclip,
    (PyArray_FastPutmaskFunc*)USHORT_fastputmask,
    (PyArray_FastTakeFunc*)USHORT_fasttake,
    (PyArray_ArgFunc*)USHORT_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr USHORT_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyUShortArrType_Type,
    PyArray_UNSIGNEDLTR,
    PyArray_USHORTLTR,
    '=',
    0,
    PyArray_USHORT,
    1*sizeof(ushort),
    _ALIGN(ushort),
    NULL,
    NULL,
    NULL,
    &_PyUShort_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyInt_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)INT_to_BOOL,
        (PyArray_VectorUnaryFunc*)INT_to_BYTE,
        (PyArray_VectorUnaryFunc*)INT_to_UBYTE,
        (PyArray_VectorUnaryFunc*)INT_to_SHORT,
        (PyArray_VectorUnaryFunc*)INT_to_USHORT,
        (PyArray_VectorUnaryFunc*)INT_to_INT,
        (PyArray_VectorUnaryFunc*)INT_to_UINT,
        (PyArray_VectorUnaryFunc*)INT_to_LONG,
        (PyArray_VectorUnaryFunc*)INT_to_ULONG,
        (PyArray_VectorUnaryFunc*)INT_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)INT_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)INT_to_FLOAT,
        (PyArray_VectorUnaryFunc*)INT_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)INT_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)INT_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)INT_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)INT_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)INT_to_OBJECT,
        (PyArray_VectorUnaryFunc*)INT_to_STRING,
        (PyArray_VectorUnaryFunc*)INT_to_UNICODE,
        (PyArray_VectorUnaryFunc*)INT_to_VOID
    },
    (PyArray_GetItemFunc*)INT_getitem,
    (PyArray_SetItemFunc*)INT_setitem,
    (PyArray_CopySwapNFunc*)INT_copyswapn,
    (PyArray_CopySwapFunc*)INT_copyswap,
    (PyArray_CompareFunc*)INT_compare,
    (PyArray_ArgFunc*)INT_argmax,
    (PyArray_DotFunc*)INT_dot,
    (PyArray_ScanFunc*)INT_scan,
    (PyArray_FromStrFunc*)INT_fromstr,
    (PyArray_NonzeroFunc*)INT_nonzero,
    (PyArray_FillFunc*)INT_fill,
    (PyArray_FillWithScalarFunc*)INT_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)INT_fastclip,
    (PyArray_FastPutmaskFunc*)INT_fastputmask,
    (PyArray_FastTakeFunc*)INT_fasttake,
    (PyArray_ArgFunc*)INT_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr INT_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyIntArrType_Type,
    PyArray_SIGNEDLTR,
    PyArray_INTLTR,
    '=',
    0,
    PyArray_INT,
    1*sizeof(int),
    _ALIGN(int),
    NULL,
    NULL,
    NULL,
    &_PyInt_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyUInt_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)UINT_to_BOOL,
        (PyArray_VectorUnaryFunc*)UINT_to_BYTE,
        (PyArray_VectorUnaryFunc*)UINT_to_UBYTE,
        (PyArray_VectorUnaryFunc*)UINT_to_SHORT,
        (PyArray_VectorUnaryFunc*)UINT_to_USHORT,
        (PyArray_VectorUnaryFunc*)UINT_to_INT,
        (PyArray_VectorUnaryFunc*)UINT_to_UINT,
        (PyArray_VectorUnaryFunc*)UINT_to_LONG,
        (PyArray_VectorUnaryFunc*)UINT_to_ULONG,
        (PyArray_VectorUnaryFunc*)UINT_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)UINT_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)UINT_to_FLOAT,
        (PyArray_VectorUnaryFunc*)UINT_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)UINT_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)UINT_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)UINT_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)UINT_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)UINT_to_OBJECT,
        (PyArray_VectorUnaryFunc*)UINT_to_STRING,
        (PyArray_VectorUnaryFunc*)UINT_to_UNICODE,
        (PyArray_VectorUnaryFunc*)UINT_to_VOID
    },
    (PyArray_GetItemFunc*)UINT_getitem,
    (PyArray_SetItemFunc*)UINT_setitem,
    (PyArray_CopySwapNFunc*)UINT_copyswapn,
    (PyArray_CopySwapFunc*)UINT_copyswap,
    (PyArray_CompareFunc*)UINT_compare,
    (PyArray_ArgFunc*)UINT_argmax,
    (PyArray_DotFunc*)UINT_dot,
    (PyArray_ScanFunc*)UINT_scan,
    (PyArray_FromStrFunc*)UINT_fromstr,
    (PyArray_NonzeroFunc*)UINT_nonzero,
    (PyArray_FillFunc*)UINT_fill,
    (PyArray_FillWithScalarFunc*)UINT_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)UINT_fastclip,
    (PyArray_FastPutmaskFunc*)UINT_fastputmask,
    (PyArray_FastTakeFunc*)UINT_fasttake,
    (PyArray_ArgFunc*)UINT_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr UINT_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyUIntArrType_Type,
    PyArray_UNSIGNEDLTR,
    PyArray_UINTLTR,
    '=',
    0,
    PyArray_UINT,
    1*sizeof(uint),
    _ALIGN(uint),
    NULL,
    NULL,
    NULL,
    &_PyUInt_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyLong_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)LONG_to_BOOL,
        (PyArray_VectorUnaryFunc*)LONG_to_BYTE,
        (PyArray_VectorUnaryFunc*)LONG_to_UBYTE,
        (PyArray_VectorUnaryFunc*)LONG_to_SHORT,
        (PyArray_VectorUnaryFunc*)LONG_to_USHORT,
        (PyArray_VectorUnaryFunc*)LONG_to_INT,
        (PyArray_VectorUnaryFunc*)LONG_to_UINT,
        (PyArray_VectorUnaryFunc*)LONG_to_LONG,
        (PyArray_VectorUnaryFunc*)LONG_to_ULONG,
        (PyArray_VectorUnaryFunc*)LONG_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)LONG_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)LONG_to_FLOAT,
        (PyArray_VectorUnaryFunc*)LONG_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)LONG_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)LONG_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)LONG_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)LONG_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)LONG_to_OBJECT,
        (PyArray_VectorUnaryFunc*)LONG_to_STRING,
        (PyArray_VectorUnaryFunc*)LONG_to_UNICODE,
        (PyArray_VectorUnaryFunc*)LONG_to_VOID
    },
    (PyArray_GetItemFunc*)LONG_getitem,
    (PyArray_SetItemFunc*)LONG_setitem,
    (PyArray_CopySwapNFunc*)LONG_copyswapn,
    (PyArray_CopySwapFunc*)LONG_copyswap,
    (PyArray_CompareFunc*)LONG_compare,
    (PyArray_ArgFunc*)LONG_argmax,
    (PyArray_DotFunc*)LONG_dot,
    (PyArray_ScanFunc*)LONG_scan,
    (PyArray_FromStrFunc*)LONG_fromstr,
    (PyArray_NonzeroFunc*)LONG_nonzero,
    (PyArray_FillFunc*)LONG_fill,
    (PyArray_FillWithScalarFunc*)LONG_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)LONG_fastclip,
    (PyArray_FastPutmaskFunc*)LONG_fastputmask,
    (PyArray_FastTakeFunc*)LONG_fasttake,
    (PyArray_ArgFunc*)LONG_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr LONG_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyLongArrType_Type,
    PyArray_SIGNEDLTR,
    PyArray_LONGLTR,
    '=',
    0,
    PyArray_LONG,
    1*sizeof(long),
    _ALIGN(long),
    NULL,
    NULL,
    NULL,
    &_PyLong_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyULong_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)ULONG_to_BOOL,
        (PyArray_VectorUnaryFunc*)ULONG_to_BYTE,
        (PyArray_VectorUnaryFunc*)ULONG_to_UBYTE,
        (PyArray_VectorUnaryFunc*)ULONG_to_SHORT,
        (PyArray_VectorUnaryFunc*)ULONG_to_USHORT,
        (PyArray_VectorUnaryFunc*)ULONG_to_INT,
        (PyArray_VectorUnaryFunc*)ULONG_to_UINT,
        (PyArray_VectorUnaryFunc*)ULONG_to_LONG,
        (PyArray_VectorUnaryFunc*)ULONG_to_ULONG,
        (PyArray_VectorUnaryFunc*)ULONG_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)ULONG_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)ULONG_to_FLOAT,
        (PyArray_VectorUnaryFunc*)ULONG_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)ULONG_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)ULONG_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)ULONG_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)ULONG_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)ULONG_to_OBJECT,
        (PyArray_VectorUnaryFunc*)ULONG_to_STRING,
        (PyArray_VectorUnaryFunc*)ULONG_to_UNICODE,
        (PyArray_VectorUnaryFunc*)ULONG_to_VOID
    },
    (PyArray_GetItemFunc*)ULONG_getitem,
    (PyArray_SetItemFunc*)ULONG_setitem,
    (PyArray_CopySwapNFunc*)ULONG_copyswapn,
    (PyArray_CopySwapFunc*)ULONG_copyswap,
    (PyArray_CompareFunc*)ULONG_compare,
    (PyArray_ArgFunc*)ULONG_argmax,
    (PyArray_DotFunc*)ULONG_dot,
    (PyArray_ScanFunc*)ULONG_scan,
    (PyArray_FromStrFunc*)ULONG_fromstr,
    (PyArray_NonzeroFunc*)ULONG_nonzero,
    (PyArray_FillFunc*)ULONG_fill,
    (PyArray_FillWithScalarFunc*)ULONG_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)ULONG_fastclip,
    (PyArray_FastPutmaskFunc*)ULONG_fastputmask,
    (PyArray_FastTakeFunc*)ULONG_fasttake,
    (PyArray_ArgFunc*)ULONG_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr ULONG_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyULongArrType_Type,
    PyArray_UNSIGNEDLTR,
    PyArray_ULONGLTR,
    '=',
    0,
    PyArray_ULONG,
    1*sizeof(ulong),
    _ALIGN(ulong),
    NULL,
    NULL,
    NULL,
    &_PyULong_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyLongLong_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)LONGLONG_to_BOOL,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_BYTE,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_UBYTE,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_SHORT,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_USHORT,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_INT,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_UINT,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_LONG,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_ULONG,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_FLOAT,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_OBJECT,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_STRING,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_UNICODE,
        (PyArray_VectorUnaryFunc*)LONGLONG_to_VOID
    },
    (PyArray_GetItemFunc*)LONGLONG_getitem,
    (PyArray_SetItemFunc*)LONGLONG_setitem,
    (PyArray_CopySwapNFunc*)LONGLONG_copyswapn,
    (PyArray_CopySwapFunc*)LONGLONG_copyswap,
    (PyArray_CompareFunc*)LONGLONG_compare,
    (PyArray_ArgFunc*)LONGLONG_argmax,
    (PyArray_DotFunc*)LONGLONG_dot,
    (PyArray_ScanFunc*)LONGLONG_scan,
    (PyArray_FromStrFunc*)LONGLONG_fromstr,
    (PyArray_NonzeroFunc*)LONGLONG_nonzero,
    (PyArray_FillFunc*)LONGLONG_fill,
    (PyArray_FillWithScalarFunc*)LONGLONG_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)LONGLONG_fastclip,
    (PyArray_FastPutmaskFunc*)LONGLONG_fastputmask,
    (PyArray_FastTakeFunc*)LONGLONG_fasttake,
    (PyArray_ArgFunc*)LONGLONG_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr LONGLONG_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyLongLongArrType_Type,
    PyArray_SIGNEDLTR,
    PyArray_LONGLONGLTR,
    '=',
    0,
    PyArray_LONGLONG,
    1*sizeof(longlong),
    _ALIGN(longlong),
    NULL,
    NULL,
    NULL,
    &_PyLongLong_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyULongLong_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_BOOL,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_BYTE,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_UBYTE,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_SHORT,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_USHORT,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_INT,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_UINT,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_LONG,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_ULONG,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_FLOAT,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_OBJECT,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_STRING,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_UNICODE,
        (PyArray_VectorUnaryFunc*)ULONGLONG_to_VOID
    },
    (PyArray_GetItemFunc*)ULONGLONG_getitem,
    (PyArray_SetItemFunc*)ULONGLONG_setitem,
    (PyArray_CopySwapNFunc*)ULONGLONG_copyswapn,
    (PyArray_CopySwapFunc*)ULONGLONG_copyswap,
    (PyArray_CompareFunc*)ULONGLONG_compare,
    (PyArray_ArgFunc*)ULONGLONG_argmax,
    (PyArray_DotFunc*)ULONGLONG_dot,
    (PyArray_ScanFunc*)ULONGLONG_scan,
    (PyArray_FromStrFunc*)ULONGLONG_fromstr,
    (PyArray_NonzeroFunc*)ULONGLONG_nonzero,
    (PyArray_FillFunc*)ULONGLONG_fill,
    (PyArray_FillWithScalarFunc*)ULONGLONG_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)ULONGLONG_fastclip,
    (PyArray_FastPutmaskFunc*)ULONGLONG_fastputmask,
    (PyArray_FastTakeFunc*)ULONGLONG_fasttake,
    (PyArray_ArgFunc*)ULONGLONG_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr ULONGLONG_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyULongLongArrType_Type,
    PyArray_UNSIGNEDLTR,
    PyArray_ULONGLONGLTR,
    '=',
    0,
    PyArray_ULONGLONG,
    1*sizeof(ulonglong),
    _ALIGN(ulonglong),
    NULL,
    NULL,
    NULL,
    &_PyULongLong_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyHalf_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)HALF_to_BOOL,
        (PyArray_VectorUnaryFunc*)HALF_to_BYTE,
        (PyArray_VectorUnaryFunc*)HALF_to_UBYTE,
        (PyArray_VectorUnaryFunc*)HALF_to_SHORT,
        (PyArray_VectorUnaryFunc*)HALF_to_USHORT,
        (PyArray_VectorUnaryFunc*)HALF_to_INT,
        (PyArray_VectorUnaryFunc*)HALF_to_UINT,
        (PyArray_VectorUnaryFunc*)HALF_to_LONG,
        (PyArray_VectorUnaryFunc*)HALF_to_ULONG,
        (PyArray_VectorUnaryFunc*)HALF_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)HALF_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)HALF_to_FLOAT,
        (PyArray_VectorUnaryFunc*)HALF_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)HALF_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)HALF_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)HALF_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)HALF_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)HALF_to_OBJECT,
        (PyArray_VectorUnaryFunc*)HALF_to_STRING,
        (PyArray_VectorUnaryFunc*)HALF_to_UNICODE,
        (PyArray_VectorUnaryFunc*)HALF_to_VOID
    },
    (PyArray_GetItemFunc*)HALF_getitem,
    (PyArray_SetItemFunc*)HALF_setitem,
    (PyArray_CopySwapNFunc*)HALF_copyswapn,
    (PyArray_CopySwapFunc*)HALF_copyswap,
    (PyArray_CompareFunc*)HALF_compare,
    (PyArray_ArgFunc*)HALF_argmax,
    (PyArray_DotFunc*)HALF_dot,
    (PyArray_ScanFunc*)HALF_scan,
    (PyArray_FromStrFunc*)HALF_fromstr,
    (PyArray_NonzeroFunc*)HALF_nonzero,
    (PyArray_FillFunc*)HALF_fill,
    (PyArray_FillWithScalarFunc*)HALF_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)HALF_fastclip,
    (PyArray_FastPutmaskFunc*)HALF_fastputmask,
    (PyArray_FastTakeFunc*)HALF_fasttake,
    (PyArray_ArgFunc*)HALF_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr HALF_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyHalfArrType_Type,
    PyArray_FLOATINGLTR,
    PyArray_HALFLTR,
    '=',
    0,
    PyArray_HALF,
    1*sizeof(npy_half),
    _ALIGN(npy_half),
    NULL,
    NULL,
    NULL,
    &_PyHalf_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyFloat_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)FLOAT_to_BOOL,
        (PyArray_VectorUnaryFunc*)FLOAT_to_BYTE,
        (PyArray_VectorUnaryFunc*)FLOAT_to_UBYTE,
        (PyArray_VectorUnaryFunc*)FLOAT_to_SHORT,
        (PyArray_VectorUnaryFunc*)FLOAT_to_USHORT,
        (PyArray_VectorUnaryFunc*)FLOAT_to_INT,
        (PyArray_VectorUnaryFunc*)FLOAT_to_UINT,
        (PyArray_VectorUnaryFunc*)FLOAT_to_LONG,
        (PyArray_VectorUnaryFunc*)FLOAT_to_ULONG,
        (PyArray_VectorUnaryFunc*)FLOAT_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)FLOAT_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)FLOAT_to_FLOAT,
        (PyArray_VectorUnaryFunc*)FLOAT_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)FLOAT_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)FLOAT_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)FLOAT_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)FLOAT_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)FLOAT_to_OBJECT,
        (PyArray_VectorUnaryFunc*)FLOAT_to_STRING,
        (PyArray_VectorUnaryFunc*)FLOAT_to_UNICODE,
        (PyArray_VectorUnaryFunc*)FLOAT_to_VOID
    },
    (PyArray_GetItemFunc*)FLOAT_getitem,
    (PyArray_SetItemFunc*)FLOAT_setitem,
    (PyArray_CopySwapNFunc*)FLOAT_copyswapn,
    (PyArray_CopySwapFunc*)FLOAT_copyswap,
    (PyArray_CompareFunc*)FLOAT_compare,
    (PyArray_ArgFunc*)FLOAT_argmax,
    (PyArray_DotFunc*)FLOAT_dot,
    (PyArray_ScanFunc*)FLOAT_scan,
    (PyArray_FromStrFunc*)FLOAT_fromstr,
    (PyArray_NonzeroFunc*)FLOAT_nonzero,
    (PyArray_FillFunc*)FLOAT_fill,
    (PyArray_FillWithScalarFunc*)FLOAT_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)FLOAT_fastclip,
    (PyArray_FastPutmaskFunc*)FLOAT_fastputmask,
    (PyArray_FastTakeFunc*)FLOAT_fasttake,
    (PyArray_ArgFunc*)FLOAT_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr FLOAT_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyFloatArrType_Type,
    PyArray_FLOATINGLTR,
    PyArray_FLOATLTR,
    '=',
    0,
    PyArray_FLOAT,
    1*sizeof(float),
    _ALIGN(float),
    NULL,
    NULL,
    NULL,
    &_PyFloat_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyDouble_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)DOUBLE_to_BOOL,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_BYTE,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_UBYTE,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_SHORT,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_USHORT,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_INT,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_UINT,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_LONG,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_ULONG,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_FLOAT,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_OBJECT,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_STRING,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_UNICODE,
        (PyArray_VectorUnaryFunc*)DOUBLE_to_VOID
    },
    (PyArray_GetItemFunc*)DOUBLE_getitem,
    (PyArray_SetItemFunc*)DOUBLE_setitem,
    (PyArray_CopySwapNFunc*)DOUBLE_copyswapn,
    (PyArray_CopySwapFunc*)DOUBLE_copyswap,
    (PyArray_CompareFunc*)DOUBLE_compare,
    (PyArray_ArgFunc*)DOUBLE_argmax,
    (PyArray_DotFunc*)DOUBLE_dot,
    (PyArray_ScanFunc*)DOUBLE_scan,
    (PyArray_FromStrFunc*)DOUBLE_fromstr,
    (PyArray_NonzeroFunc*)DOUBLE_nonzero,
    (PyArray_FillFunc*)DOUBLE_fill,
    (PyArray_FillWithScalarFunc*)DOUBLE_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)DOUBLE_fastclip,
    (PyArray_FastPutmaskFunc*)DOUBLE_fastputmask,
    (PyArray_FastTakeFunc*)DOUBLE_fasttake,
    (PyArray_ArgFunc*)DOUBLE_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr DOUBLE_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyDoubleArrType_Type,
    PyArray_FLOATINGLTR,
    PyArray_DOUBLELTR,
    '=',
    0,
    PyArray_DOUBLE,
    1*sizeof(double),
    _ALIGN(double),
    NULL,
    NULL,
    NULL,
    &_PyDouble_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyLongDouble_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_BOOL,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_BYTE,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_UBYTE,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_SHORT,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_USHORT,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_INT,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_UINT,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_LONG,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_ULONG,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_FLOAT,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_OBJECT,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_STRING,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_UNICODE,
        (PyArray_VectorUnaryFunc*)LONGDOUBLE_to_VOID
    },
    (PyArray_GetItemFunc*)LONGDOUBLE_getitem,
    (PyArray_SetItemFunc*)LONGDOUBLE_setitem,
    (PyArray_CopySwapNFunc*)LONGDOUBLE_copyswapn,
    (PyArray_CopySwapFunc*)LONGDOUBLE_copyswap,
    (PyArray_CompareFunc*)LONGDOUBLE_compare,
    (PyArray_ArgFunc*)LONGDOUBLE_argmax,
    (PyArray_DotFunc*)LONGDOUBLE_dot,
    (PyArray_ScanFunc*)LONGDOUBLE_scan,
    (PyArray_FromStrFunc*)LONGDOUBLE_fromstr,
    (PyArray_NonzeroFunc*)LONGDOUBLE_nonzero,
    (PyArray_FillFunc*)LONGDOUBLE_fill,
    (PyArray_FillWithScalarFunc*)LONGDOUBLE_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)LONGDOUBLE_fastclip,
    (PyArray_FastPutmaskFunc*)LONGDOUBLE_fastputmask,
    (PyArray_FastTakeFunc*)LONGDOUBLE_fasttake,
    (PyArray_ArgFunc*)LONGDOUBLE_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr LONGDOUBLE_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyLongDoubleArrType_Type,
    PyArray_FLOATINGLTR,
    PyArray_LONGDOUBLELTR,
    '=',
    0,
    PyArray_LONGDOUBLE,
    1*sizeof(longdouble),
    _ALIGN(longdouble),
    NULL,
    NULL,
    NULL,
    &_PyLongDouble_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyCFloat_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)CFLOAT_to_BOOL,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_BYTE,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_UBYTE,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_SHORT,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_USHORT,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_INT,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_UINT,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_LONG,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_ULONG,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_FLOAT,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_OBJECT,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_STRING,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_UNICODE,
        (PyArray_VectorUnaryFunc*)CFLOAT_to_VOID
    },
    (PyArray_GetItemFunc*)CFLOAT_getitem,
    (PyArray_SetItemFunc*)CFLOAT_setitem,
    (PyArray_CopySwapNFunc*)CFLOAT_copyswapn,
    (PyArray_CopySwapFunc*)CFLOAT_copyswap,
    (PyArray_CompareFunc*)CFLOAT_compare,
    (PyArray_ArgFunc*)CFLOAT_argmax,
    (PyArray_DotFunc*)CFLOAT_dot,
    (PyArray_ScanFunc*)CFLOAT_scan,
    (PyArray_FromStrFunc*)CFLOAT_fromstr,
    (PyArray_NonzeroFunc*)CFLOAT_nonzero,
    (PyArray_FillFunc*)CFLOAT_fill,
    (PyArray_FillWithScalarFunc*)CFLOAT_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)CFLOAT_fastclip,
    (PyArray_FastPutmaskFunc*)CFLOAT_fastputmask,
    (PyArray_FastTakeFunc*)CFLOAT_fasttake,
    (PyArray_ArgFunc*)CFLOAT_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr CFLOAT_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyCFloatArrType_Type,
    PyArray_COMPLEXLTR,
    PyArray_CFLOATLTR,
    '=',
    0,
    PyArray_CFLOAT,
    2*sizeof(float),
    _ALIGN(float),
    NULL,
    NULL,
    NULL,
    &_PyCFloat_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyCDouble_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_BOOL,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_BYTE,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_UBYTE,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_SHORT,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_USHORT,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_INT,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_UINT,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_LONG,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_ULONG,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_FLOAT,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_OBJECT,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_STRING,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_UNICODE,
        (PyArray_VectorUnaryFunc*)CDOUBLE_to_VOID
    },
    (PyArray_GetItemFunc*)CDOUBLE_getitem,
    (PyArray_SetItemFunc*)CDOUBLE_setitem,
    (PyArray_CopySwapNFunc*)CDOUBLE_copyswapn,
    (PyArray_CopySwapFunc*)CDOUBLE_copyswap,
    (PyArray_CompareFunc*)CDOUBLE_compare,
    (PyArray_ArgFunc*)CDOUBLE_argmax,
    (PyArray_DotFunc*)CDOUBLE_dot,
    (PyArray_ScanFunc*)CDOUBLE_scan,
    (PyArray_FromStrFunc*)CDOUBLE_fromstr,
    (PyArray_NonzeroFunc*)CDOUBLE_nonzero,
    (PyArray_FillFunc*)CDOUBLE_fill,
    (PyArray_FillWithScalarFunc*)CDOUBLE_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)CDOUBLE_fastclip,
    (PyArray_FastPutmaskFunc*)CDOUBLE_fastputmask,
    (PyArray_FastTakeFunc*)CDOUBLE_fasttake,
    (PyArray_ArgFunc*)CDOUBLE_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr CDOUBLE_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyCDoubleArrType_Type,
    PyArray_COMPLEXLTR,
    PyArray_CDOUBLELTR,
    '=',
    0,
    PyArray_CDOUBLE,
    2*sizeof(double),
    _ALIGN(double),
    NULL,
    NULL,
    NULL,
    &_PyCDouble_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyCLongDouble_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_BOOL,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_BYTE,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_UBYTE,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_SHORT,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_USHORT,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_INT,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_UINT,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_LONG,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_ULONG,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_FLOAT,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_OBJECT,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_STRING,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_UNICODE,
        (PyArray_VectorUnaryFunc*)CLONGDOUBLE_to_VOID
    },
    (PyArray_GetItemFunc*)CLONGDOUBLE_getitem,
    (PyArray_SetItemFunc*)CLONGDOUBLE_setitem,
    (PyArray_CopySwapNFunc*)CLONGDOUBLE_copyswapn,
    (PyArray_CopySwapFunc*)CLONGDOUBLE_copyswap,
    (PyArray_CompareFunc*)CLONGDOUBLE_compare,
    (PyArray_ArgFunc*)CLONGDOUBLE_argmax,
    (PyArray_DotFunc*)CLONGDOUBLE_dot,
    (PyArray_ScanFunc*)CLONGDOUBLE_scan,
    (PyArray_FromStrFunc*)CLONGDOUBLE_fromstr,
    (PyArray_NonzeroFunc*)CLONGDOUBLE_nonzero,
    (PyArray_FillFunc*)CLONGDOUBLE_fill,
    (PyArray_FillWithScalarFunc*)CLONGDOUBLE_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)CLONGDOUBLE_fastclip,
    (PyArray_FastPutmaskFunc*)CLONGDOUBLE_fastputmask,
    (PyArray_FastTakeFunc*)CLONGDOUBLE_fasttake,
    (PyArray_ArgFunc*)CLONGDOUBLE_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr CLONGDOUBLE_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyCLongDoubleArrType_Type,
    PyArray_COMPLEXLTR,
    PyArray_CLONGDOUBLELTR,
    '=',
    0,
    PyArray_CLONGDOUBLE,
    2*sizeof(longdouble),
    _ALIGN(longdouble),
    NULL,
    NULL,
    NULL,
    &_PyCLongDouble_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyObject_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)OBJECT_to_BOOL,
        (PyArray_VectorUnaryFunc*)OBJECT_to_BYTE,
        (PyArray_VectorUnaryFunc*)OBJECT_to_UBYTE,
        (PyArray_VectorUnaryFunc*)OBJECT_to_SHORT,
        (PyArray_VectorUnaryFunc*)OBJECT_to_USHORT,
        (PyArray_VectorUnaryFunc*)OBJECT_to_INT,
        (PyArray_VectorUnaryFunc*)OBJECT_to_UINT,
        (PyArray_VectorUnaryFunc*)OBJECT_to_LONG,
        (PyArray_VectorUnaryFunc*)OBJECT_to_ULONG,
        (PyArray_VectorUnaryFunc*)OBJECT_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)OBJECT_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)OBJECT_to_FLOAT,
        (PyArray_VectorUnaryFunc*)OBJECT_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)OBJECT_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)OBJECT_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)OBJECT_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)OBJECT_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)OBJECT_to_OBJECT,
        (PyArray_VectorUnaryFunc*)OBJECT_to_STRING,
        (PyArray_VectorUnaryFunc*)OBJECT_to_UNICODE,
        (PyArray_VectorUnaryFunc*)OBJECT_to_VOID
    },
    (PyArray_GetItemFunc*)OBJECT_getitem,
    (PyArray_SetItemFunc*)OBJECT_setitem,
    (PyArray_CopySwapNFunc*)OBJECT_copyswapn,
    (PyArray_CopySwapFunc*)OBJECT_copyswap,
    (PyArray_CompareFunc*)OBJECT_compare,
    (PyArray_ArgFunc*)OBJECT_argmax,
    (PyArray_DotFunc*)OBJECT_dot,
    (PyArray_ScanFunc*)OBJECT_scan,
    (PyArray_FromStrFunc*)OBJECT_fromstr,
    (PyArray_NonzeroFunc*)OBJECT_nonzero,
    (PyArray_FillFunc*)OBJECT_fill,
    (PyArray_FillWithScalarFunc*)OBJECT_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)OBJECT_fastclip,
    (PyArray_FastPutmaskFunc*)OBJECT_fastputmask,
    (PyArray_FastTakeFunc*)OBJECT_fasttake,
    (PyArray_ArgFunc*)OBJECT_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr OBJECT_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyObjectArrType_Type,
    PyArray_OBJECTLTR,
    PyArray_OBJECTLTR,
    '|',
    NPY_OBJECT_DTYPE_FLAGS,
    PyArray_OBJECT,
    1*sizeof(PyObject *),
    _ALIGN(PyObject *),
    NULL,
    NULL,
    NULL,
    &_PyObject_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyDatetime_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)DATETIME_to_BOOL,
        (PyArray_VectorUnaryFunc*)DATETIME_to_BYTE,
        (PyArray_VectorUnaryFunc*)DATETIME_to_UBYTE,
        (PyArray_VectorUnaryFunc*)DATETIME_to_SHORT,
        (PyArray_VectorUnaryFunc*)DATETIME_to_USHORT,
        (PyArray_VectorUnaryFunc*)DATETIME_to_INT,
        (PyArray_VectorUnaryFunc*)DATETIME_to_UINT,
        (PyArray_VectorUnaryFunc*)DATETIME_to_LONG,
        (PyArray_VectorUnaryFunc*)DATETIME_to_ULONG,
        (PyArray_VectorUnaryFunc*)DATETIME_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)DATETIME_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)DATETIME_to_FLOAT,
        (PyArray_VectorUnaryFunc*)DATETIME_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)DATETIME_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)DATETIME_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)DATETIME_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)DATETIME_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)DATETIME_to_OBJECT,
        (PyArray_VectorUnaryFunc*)DATETIME_to_STRING,
        (PyArray_VectorUnaryFunc*)DATETIME_to_UNICODE,
        (PyArray_VectorUnaryFunc*)DATETIME_to_VOID
    },
    (PyArray_GetItemFunc*)DATETIME_getitem,
    (PyArray_SetItemFunc*)DATETIME_setitem,
    (PyArray_CopySwapNFunc*)DATETIME_copyswapn,
    (PyArray_CopySwapFunc*)DATETIME_copyswap,
    (PyArray_CompareFunc*)DATETIME_compare,
    (PyArray_ArgFunc*)DATETIME_argmax,
    (PyArray_DotFunc*)DATETIME_dot,
    (PyArray_ScanFunc*)DATETIME_scan,
    (PyArray_FromStrFunc*)DATETIME_fromstr,
    (PyArray_NonzeroFunc*)DATETIME_nonzero,
    (PyArray_FillFunc*)DATETIME_fill,
    (PyArray_FillWithScalarFunc*)DATETIME_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)DATETIME_fastclip,
    (PyArray_FastPutmaskFunc*)DATETIME_fastputmask,
    (PyArray_FastTakeFunc*)DATETIME_fasttake,
    (PyArray_ArgFunc*)DATETIME_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr DATETIME_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyDatetimeArrType_Type,
    PyArray_DATETIMELTR,
    PyArray_DATETIMELTR,
    '=',
    0,
    PyArray_DATETIME,
    1*sizeof(datetime),
    _ALIGN(datetime),
    NULL,
    NULL,
    NULL,
    &_PyDatetime_ArrFuncs,
    NULL,
};


#line 3804
static PyArray_ArrFuncs _PyTimedelta_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_BOOL,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_BYTE,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_UBYTE,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_SHORT,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_USHORT,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_INT,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_UINT,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_LONG,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_ULONG,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_FLOAT,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_OBJECT,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_STRING,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_UNICODE,
        (PyArray_VectorUnaryFunc*)TIMEDELTA_to_VOID
    },
    (PyArray_GetItemFunc*)TIMEDELTA_getitem,
    (PyArray_SetItemFunc*)TIMEDELTA_setitem,
    (PyArray_CopySwapNFunc*)TIMEDELTA_copyswapn,
    (PyArray_CopySwapFunc*)TIMEDELTA_copyswap,
    (PyArray_CompareFunc*)TIMEDELTA_compare,
    (PyArray_ArgFunc*)TIMEDELTA_argmax,
    (PyArray_DotFunc*)TIMEDELTA_dot,
    (PyArray_ScanFunc*)TIMEDELTA_scan,
    (PyArray_FromStrFunc*)TIMEDELTA_fromstr,
    (PyArray_NonzeroFunc*)TIMEDELTA_nonzero,
    (PyArray_FillFunc*)TIMEDELTA_fill,
    (PyArray_FillWithScalarFunc*)TIMEDELTA_fillwithscalar,
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)TIMEDELTA_fastclip,
    (PyArray_FastPutmaskFunc*)TIMEDELTA_fastputmask,
    (PyArray_FastTakeFunc*)TIMEDELTA_fasttake,
    (PyArray_ArgFunc*)TIMEDELTA_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr TIMEDELTA_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    &PyTimedeltaArrType_Type,
    PyArray_TIMEDELTALTR,
    PyArray_TIMEDELTALTR,
    '=',
    0,
    PyArray_TIMEDELTA,
    1*sizeof(timedelta),
    _ALIGN(timedelta),
    NULL,
    NULL,
    NULL,
    &_PyTimedelta_ArrFuncs,
    NULL,
};



static void
_init_datetime_descr(PyArray_Descr *descr)
{
    PyArray_DatetimeMetaData *dt_data;
    PyObject *cobj;

    dt_data = _pya_malloc(sizeof(PyArray_DatetimeMetaData));
    dt_data->base = NPY_FR_us;
    dt_data->num = 1;
    dt_data->den = 1;
    dt_data->events = 1;

/* FIXME
 * There is no error check here and no way to indicate an error
 * until the metadata turns up NULL.
 */
    cobj = NpyCapsule_FromVoidPtr((void *)dt_data, simple_capsule_dtor);
    descr->metadata = PyDict_New();
    PyDict_SetItemString(descr->metadata, NPY_METADATA_DTSTR, cobj);
    Py_DECREF(cobj);

}

#define _MAX_LETTER 128
static char _letter_to_num[_MAX_LETTER];

static PyArray_Descr *_builtin_descrs[] = {
    &BOOL_Descr,
    &BYTE_Descr,
    &UBYTE_Descr,
    &SHORT_Descr,
    &USHORT_Descr,
    &INT_Descr,
    &UINT_Descr,
    &LONG_Descr,
    &ULONG_Descr,
    &LONGLONG_Descr,
    &ULONGLONG_Descr,
    &FLOAT_Descr,
    &DOUBLE_Descr,
    &LONGDOUBLE_Descr,
    &CFLOAT_Descr,
    &CDOUBLE_Descr,
    &CLONGDOUBLE_Descr,
    &OBJECT_Descr,
    &STRING_Descr,
    &UNICODE_Descr,
    &VOID_Descr,
    &DATETIME_Descr,
    &TIMEDELTA_Descr,
    &HALF_Descr
};

/*NUMPY_API
 * Get the PyArray_Descr structure for a type.
 */
NPY_NO_EXPORT PyArray_Descr *
PyArray_DescrFromType(int type)
{
    PyArray_Descr *ret = NULL;

    if (type < PyArray_NTYPES) {
        ret = _builtin_descrs[type];
    }
    else if (type == PyArray_NOTYPE) {
        /*
         * This needs to not raise an error so
         * that PyArray_DescrFromType(PyArray_NOTYPE)
         * works for backwards-compatible C-API
         */
        return NULL;
    }
    else if ((type == PyArray_CHAR) || (type == PyArray_CHARLTR)) {
        ret = PyArray_DescrNew(_builtin_descrs[PyArray_STRING]);
        if (ret == NULL) {
            return NULL;
        }
        ret->elsize = 1;
        ret->type = PyArray_CHARLTR;
        return ret;
    }
    else if (PyTypeNum_ISUSERDEF(type)) {
        ret = userdescrs[type - PyArray_USERDEF];
    }
    else {
        int num = PyArray_NTYPES;
        if (type < _MAX_LETTER) {
            num = (int) _letter_to_num[type];
        }
        if (num >= PyArray_NTYPES) {
            ret = NULL;
        }
        else {
            ret = _builtin_descrs[num];
        }
    }
    if (ret == NULL) {
        PyErr_SetString(PyExc_ValueError,
                "Invalid data-type for array");
    }
    else {
        Py_INCREF(ret);
    }

    /* Make sure dtype metadata is initialized for DATETIME */
    if (PyTypeNum_ISDATETIME(type)) {
        if (ret->metadata == NULL) {
            _init_datetime_descr(ret);
        }
    }

    return ret;
}


/*
 *****************************************************************************
 **                             SETUP TYPE INFO                             **
 *****************************************************************************
 */


NPY_NO_EXPORT int
set_typeinfo(PyObject *dict)
{
    PyObject *infodict, *s;
    int i;

    PyArray_Descr *dtype;
    PyObject *cobj, *key;

    /* Add cast functions for the new types */
#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_BOOL];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)BOOL_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_BOOL];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)BOOL_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_BOOL];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)BOOL_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_BYTE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)BYTE_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_BYTE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)BYTE_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_BYTE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)BYTE_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_UBYTE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UBYTE_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_UBYTE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UBYTE_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_UBYTE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UBYTE_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_SHORT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)SHORT_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_SHORT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)SHORT_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_SHORT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)SHORT_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_USHORT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)USHORT_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_USHORT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)USHORT_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_USHORT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)USHORT_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_INT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)INT_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_INT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)INT_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_INT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)INT_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_UINT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UINT_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_UINT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UINT_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_UINT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UINT_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_LONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONG_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_LONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONG_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_LONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONG_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_ULONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)ULONG_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_ULONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)ULONG_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_ULONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)ULONG_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_LONGLONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONGLONG_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_LONGLONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONGLONG_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_LONGLONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONGLONG_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_ULONGLONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)ULONGLONG_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_ULONGLONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)ULONGLONG_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_ULONGLONG];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)ULONGLONG_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_HALF];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)HALF_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_HALF];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)HALF_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_HALF];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)HALF_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_FLOAT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)FLOAT_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_FLOAT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)FLOAT_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_FLOAT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)FLOAT_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_DOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)DOUBLE_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_DOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)DOUBLE_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_DOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)DOUBLE_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_LONGDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONGDOUBLE_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_LONGDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONGDOUBLE_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_LONGDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)LONGDOUBLE_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_CFLOAT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CFLOAT_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_CFLOAT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CFLOAT_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_CFLOAT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CFLOAT_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_CDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CDOUBLE_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_CDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CDOUBLE_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_CDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CDOUBLE_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_CLONGDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CLONGDOUBLE_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_CLONGDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CLONGDOUBLE_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_CLONGDOUBLE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)CLONGDOUBLE_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_OBJECT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)OBJECT_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_OBJECT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)OBJECT_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_OBJECT];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)OBJECT_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_STRING];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)STRING_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_STRING];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)STRING_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_STRING];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)STRING_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_UNICODE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UNICODE_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_UNICODE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UNICODE_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_UNICODE];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)UNICODE_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_VOID];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)VOID_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_VOID];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)VOID_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_VOID];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)VOID_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_DATETIME];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)DATETIME_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_DATETIME];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)DATETIME_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_DATETIME];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)DATETIME_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);


#line 4017
#line 4021
    dtype = _builtin_descrs[NPY_TIMEDELTA];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_HALF);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)TIMEDELTA_to_HALF, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_TIMEDELTA];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_DATETIME);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)TIMEDELTA_to_DATETIME, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

#line 4021
    dtype = _builtin_descrs[NPY_TIMEDELTA];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_TIMEDELTA);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)TIMEDELTA_to_TIMEDELTA, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);



    for (i = 0; i < _MAX_LETTER; i++) {
        _letter_to_num[i] = NPY_NTYPES;
    }

#line 4058
    _letter_to_num[PyArray_BOOLLTR] = PyArray_BOOL;

#line 4058
    _letter_to_num[PyArray_BYTELTR] = PyArray_BYTE;

#line 4058
    _letter_to_num[PyArray_UBYTELTR] = PyArray_UBYTE;

#line 4058
    _letter_to_num[PyArray_SHORTLTR] = PyArray_SHORT;

#line 4058
    _letter_to_num[PyArray_USHORTLTR] = PyArray_USHORT;

#line 4058
    _letter_to_num[PyArray_INTLTR] = PyArray_INT;

#line 4058
    _letter_to_num[PyArray_UINTLTR] = PyArray_UINT;

#line 4058
    _letter_to_num[PyArray_INTPLTR] = PyArray_INTP;

#line 4058
    _letter_to_num[PyArray_UINTPLTR] = PyArray_UINTP;

#line 4058
    _letter_to_num[PyArray_LONGLTR] = PyArray_LONG;

#line 4058
    _letter_to_num[PyArray_ULONGLTR] = PyArray_ULONG;

#line 4058
    _letter_to_num[PyArray_LONGLONGLTR] = PyArray_LONGLONG;

#line 4058
    _letter_to_num[PyArray_ULONGLONGLTR] = PyArray_ULONGLONG;

#line 4058
    _letter_to_num[PyArray_HALFLTR] = PyArray_HALF;

#line 4058
    _letter_to_num[PyArray_FLOATLTR] = PyArray_FLOAT;

#line 4058
    _letter_to_num[PyArray_DOUBLELTR] = PyArray_DOUBLE;

#line 4058
    _letter_to_num[PyArray_LONGDOUBLELTR] = PyArray_LONGDOUBLE;

#line 4058
    _letter_to_num[PyArray_CFLOATLTR] = PyArray_CFLOAT;

#line 4058
    _letter_to_num[PyArray_CDOUBLELTR] = PyArray_CDOUBLE;

#line 4058
    _letter_to_num[PyArray_CLONGDOUBLELTR] = PyArray_CLONGDOUBLE;

#line 4058
    _letter_to_num[PyArray_OBJECTLTR] = PyArray_OBJECT;

#line 4058
    _letter_to_num[PyArray_STRINGLTR] = PyArray_STRING;

#line 4058
    _letter_to_num[PyArray_UNICODELTR] = PyArray_UNICODE;

#line 4058
    _letter_to_num[PyArray_VOIDLTR] = PyArray_VOID;

#line 4058
    _letter_to_num[PyArray_DATETIMELTR] = PyArray_DATETIME;

#line 4058
    _letter_to_num[PyArray_TIMEDELTALTR] = PyArray_TIMEDELTA;

    _letter_to_num[PyArray_STRINGLTR2] = PyArray_STRING;

#line 4068
    BOOL_Descr.fields = Py_None;

#line 4068
    BYTE_Descr.fields = Py_None;

#line 4068
    UBYTE_Descr.fields = Py_None;

#line 4068
    SHORT_Descr.fields = Py_None;

#line 4068
    USHORT_Descr.fields = Py_None;

#line 4068
    INT_Descr.fields = Py_None;

#line 4068
    UINT_Descr.fields = Py_None;

#line 4068
    LONG_Descr.fields = Py_None;

#line 4068
    ULONG_Descr.fields = Py_None;

#line 4068
    LONGLONG_Descr.fields = Py_None;

#line 4068
    ULONGLONG_Descr.fields = Py_None;

#line 4068
    HALF_Descr.fields = Py_None;

#line 4068
    FLOAT_Descr.fields = Py_None;

#line 4068
    DOUBLE_Descr.fields = Py_None;

#line 4068
    LONGDOUBLE_Descr.fields = Py_None;

#line 4068
    CFLOAT_Descr.fields = Py_None;

#line 4068
    CDOUBLE_Descr.fields = Py_None;

#line 4068
    CLONGDOUBLE_Descr.fields = Py_None;

#line 4068
    OBJECT_Descr.fields = Py_None;

#line 4068
    STRING_Descr.fields = Py_None;

#line 4068
    UNICODE_Descr.fields = Py_None;

#line 4068
    VOID_Descr.fields = Py_None;

#line 4068
    DATETIME_Descr.fields = Py_None;

#line 4068
    TIMEDELTA_Descr.fields = Py_None;


    /* Set a dictionary with type information */
    infodict = PyDict_New();
    if (infodict == NULL) return -1;

#define BITSOF_INTP CHAR_BIT*SIZEOF_PY_INTPTR_T
#define BITSOF_BYTE CHAR_BIT

#line 4099
    PyDict_SetItemString(infodict, "BOOL",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiiiO",
#else
            s = Py_BuildValue("ciiiiiO",
#endif
                PyArray_BOOLLTR,
                PyArray_BOOL,
                BITSOF_BOOL,
                _ALIGN(Bool),
                1,
                0,
                (PyObject *) &PyBoolArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "BYTE",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiiiO",
#else
            s = Py_BuildValue("ciiiiiO",
#endif
                PyArray_BYTELTR,
                PyArray_BYTE,
                BITSOF_BYTE,
                _ALIGN(byte),
                MAX_BYTE,
                MIN_BYTE,
                (PyObject *) &PyByteArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "UBYTE",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiiiO",
#else
            s = Py_BuildValue("ciiiiiO",
#endif
                PyArray_UBYTELTR,
                PyArray_UBYTE,
                BITSOF_BYTE,
                _ALIGN(ubyte),
                MAX_UBYTE,
                0,
                (PyObject *) &PyUByteArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "SHORT",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiiiO",
#else
            s = Py_BuildValue("ciiiiiO",
#endif
                PyArray_SHORTLTR,
                PyArray_SHORT,
                BITSOF_SHORT,
                _ALIGN(short),
                MAX_SHORT,
                MIN_SHORT,
                (PyObject *) &PyShortArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "USHORT",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiiiO",
#else
            s = Py_BuildValue("ciiiiiO",
#endif
                PyArray_USHORTLTR,
                PyArray_USHORT,
                BITSOF_SHORT,
                _ALIGN(ushort),
                MAX_USHORT,
                0,
                (PyObject *) &PyUShortArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "INT",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiiiO",
#else
            s = Py_BuildValue("ciiiiiO",
#endif
                PyArray_INTLTR,
                PyArray_INT,
                BITSOF_INT,
                _ALIGN(int),
                MAX_INT,
                MIN_INT,
                (PyObject *) &PyIntArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "UINT",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNiO",
#else
            s = Py_BuildValue("ciiiNiO",
#endif
                PyArray_UINTLTR,
                PyArray_UINT,
                BITSOF_INT,
                _ALIGN(uint),
                PyLong_FromUnsignedLong(MAX_UINT),
                0,
                (PyObject *) &PyUIntArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "INTP",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNNO",
#else
            s = Py_BuildValue("ciiiNNO",
#endif
                PyArray_INTPLTR,
                PyArray_INTP,
                BITSOF_INTP,
                _ALIGN(intp),
                PyLong_FromLongLong((longlong) MAX_INTP),
                PyLong_FromLongLong((longlong) MIN_INTP),
                (PyObject *) &PyIntpArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "UINTP",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNiO",
#else
            s = Py_BuildValue("ciiiNiO",
#endif
                PyArray_UINTPLTR,
                PyArray_UINTP,
                BITSOF_INTP,
                _ALIGN(uintp),
                PyLong_FromUnsignedLongLong((ulonglong) MAX_UINTP),
                0,
                (PyObject *) &PyUIntpArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "LONG",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiillO",
#else
            s = Py_BuildValue("ciiillO",
#endif
                PyArray_LONGLTR,
                PyArray_LONG,
                BITSOF_LONG,
                _ALIGN(long),
                MAX_LONG,
                MIN_LONG,
                (PyObject *) &PyLongArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "ULONG",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNiO",
#else
            s = Py_BuildValue("ciiiNiO",
#endif
                PyArray_ULONGLTR,
                PyArray_ULONG,
                BITSOF_LONG,
                _ALIGN(ulong),
                PyLong_FromUnsignedLong((unsigned long) MAX_ULONG),
                0,
                (PyObject *) &PyULongArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "LONGLONG",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNNO",
#else
            s = Py_BuildValue("ciiiNNO",
#endif
                PyArray_LONGLONGLTR,
                PyArray_LONGLONG,
                BITSOF_LONGLONG,
                _ALIGN(longlong),
                PyLong_FromLongLong((longlong) MAX_LONGLONG),
                PyLong_FromLongLong((longlong) MIN_LONGLONG),
                (PyObject *) &PyLongLongArrType_Type));
    Py_DECREF(s);

#line 4099
    PyDict_SetItemString(infodict, "ULONGLONG",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNiO",
#else
            s = Py_BuildValue("ciiiNiO",
#endif
                PyArray_ULONGLONGLTR,
                PyArray_ULONGLONG,
                BITSOF_LONGLONG,
                _ALIGN(ulonglong),
                PyLong_FromUnsignedLongLong((ulonglong) MAX_ULONGLONG),
                0,
                (PyObject *) &PyULongLongArrType_Type));
    Py_DECREF(s);


#define BITSOF_CFLOAT 2*BITSOF_FLOAT
#define BITSOF_CDOUBLE 2*BITSOF_DOUBLE
#define BITSOF_CLONGDOUBLE 2*BITSOF_LONGDOUBLE

#line 4125
    PyDict_SetItemString(infodict, "HALF",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_HALFLTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_HALFLTR,
#endif
                PyArray_HALF,
                BITSOF_HALF,
                _ALIGN(npy_half),
                (PyObject *) &PyHalfArrType_Type));
    Py_DECREF(s);

#line 4125
    PyDict_SetItemString(infodict, "FLOAT",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_FLOATLTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_FLOATLTR,
#endif
                PyArray_FLOAT,
                BITSOF_FLOAT,
                _ALIGN(float),
                (PyObject *) &PyFloatArrType_Type));
    Py_DECREF(s);

#line 4125
    PyDict_SetItemString(infodict, "DOUBLE",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_DOUBLELTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_DOUBLELTR,
#endif
                PyArray_DOUBLE,
                BITSOF_DOUBLE,
                _ALIGN(double),
                (PyObject *) &PyDoubleArrType_Type));
    Py_DECREF(s);

#line 4125
    PyDict_SetItemString(infodict, "LONGDOUBLE",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_LONGDOUBLELTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_LONGDOUBLELTR,
#endif
                PyArray_LONGDOUBLE,
                BITSOF_LONGDOUBLE,
                _ALIGN(longdouble),
                (PyObject *) &PyLongDoubleArrType_Type));
    Py_DECREF(s);

#line 4125
    PyDict_SetItemString(infodict, "CFLOAT",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_CFLOATLTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_CFLOATLTR,
#endif
                PyArray_CFLOAT,
                BITSOF_CFLOAT,
                _ALIGN(cfloat),
                (PyObject *) &PyCFloatArrType_Type));
    Py_DECREF(s);

#line 4125
    PyDict_SetItemString(infodict, "CDOUBLE",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_CDOUBLELTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_CDOUBLELTR,
#endif
                PyArray_CDOUBLE,
                BITSOF_CDOUBLE,
                _ALIGN(cdouble),
                (PyObject *) &PyCDoubleArrType_Type));
    Py_DECREF(s);

#line 4125
    PyDict_SetItemString(infodict, "CLONGDOUBLE",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_CLONGDOUBLELTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_CLONGDOUBLELTR,
#endif
                PyArray_CLONGDOUBLE,
                BITSOF_CLONGDOUBLE,
                _ALIGN(clongdouble),
                (PyObject *) &PyCLongDoubleArrType_Type));
    Py_DECREF(s);


    PyDict_SetItemString(infodict, "OBJECT",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_OBJECTLTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_OBJECTLTR,
#endif
                PyArray_OBJECT,
                sizeof(PyObject *) * CHAR_BIT,
                _ALIGN(PyObject *),
                (PyObject *) &PyObjectArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "STRING",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_STRINGLTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_STRINGLTR,
#endif
                PyArray_STRING,
                0,
                _ALIGN(char),
                (PyObject *) &PyStringArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "UNICODE",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_UNICODELTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_UNICODELTR,
#endif
                PyArray_UNICODE,
                0,
                _ALIGN(PyArray_UCS4),
                (PyObject *) &PyUnicodeArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "VOID",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", PyArray_VOIDLTR,
#else
            s = Py_BuildValue("ciiiO", PyArray_VOIDLTR,
#endif
                PyArray_VOID,
                0,
                _ALIGN(char),
                (PyObject *) &PyVoidArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "DATETIME",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNNO", PyArray_DATETIMELTR,
#else
            s = Py_BuildValue("ciiiNNO", PyArray_DATETIMELTR,
#endif
                PyArray_DATETIME,
                sizeof(npy_datetime) * CHAR_BIT,
                _ALIGN(npy_datetime),
                MyPyLong_FromInt64(MAX_DATETIME),
                MyPyLong_FromInt64(MIN_DATETIME),
                (PyObject *) &PyDatetimeArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "TIMEDELTA",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNNO", PyArray_TIMEDELTALTR,
#else
            s = Py_BuildValue("ciiiNNO",PyArray_TIMEDELTALTR,
#endif
                PyArray_TIMEDELTA,
                sizeof(npy_timedelta) * CHAR_BIT,
                _ALIGN(npy_timedelta),
                MyPyLong_FromInt64(MAX_TIMEDELTA),
                MyPyLong_FromInt64(MIN_TIMEDELTA),
                (PyObject *)&PyTimedeltaArrType_Type));
    Py_DECREF(s);

#define SETTYPE(name)                           \
    Py_INCREF(&Py##name##ArrType_Type);         \
    PyDict_SetItemString(infodict, #name,       \
            (PyObject *)&Py##name##ArrType_Type)

    SETTYPE(Generic);
    SETTYPE(Number);
    SETTYPE(Integer);
    SETTYPE(Inexact);
    SETTYPE(SignedInteger);
    SETTYPE(TimeInteger);
    SETTYPE(UnsignedInteger);
    SETTYPE(Floating);
    SETTYPE(ComplexFloating);
    SETTYPE(Flexible);
    SETTYPE(Character);

#undef SETTYPE

    PyDict_SetItemString(dict, "typeinfo", infodict);
    Py_DECREF(infodict);
    return 0;
}

#undef _MAX_LETTER

